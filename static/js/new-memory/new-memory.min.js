/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAllBodyScrollLocks: function() { return /* binding */ clearAllBodyScrollLocks; },\n/* harmony export */   disableBodyScroll: function() { return /* binding */ disableBodyScroll; },\n/* harmony export */   enableBodyScroll: function() { return /* binding */ enableBodyScroll; }\n/* harmony export */ });\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\n// Older browsers don't support event options, feature detect it.\n\n// Adopted and modified solution from Bohdan Didukh (2017)\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\n\nvar hasPassiveEvents = false;\nif (typeof window !== 'undefined') {\n  var passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true;\n      return undefined;\n    }\n  };\n  window.addEventListener('testPassive', null, passiveTestOptions);\n  window.removeEventListener('testPassive', null, passiveTestOptions);\n}\nvar isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);\nvar locks = [];\nvar documentListenerAdded = false;\nvar initialClientY = -1;\nvar previousBodyOverflowSetting = void 0;\nvar previousBodyPaddingRight = void 0;\n\n// returns true if `el` should be allowed to receive touchmove events.\nvar allowTouchMove = function allowTouchMove(el) {\n  return locks.some(function (lock) {\n    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n      return true;\n    }\n    return false;\n  });\n};\nvar preventDefault = function preventDefault(rawEvent) {\n  var e = rawEvent || window.event;\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true;\n  }\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true;\n  if (e.preventDefault) e.preventDefault();\n  return false;\n};\nvar setOverflowHidden = function setOverflowHidden(options) {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\n    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n    if (_reserveScrollBarGap && scrollBarGap > 0) {\n      previousBodyPaddingRight = document.body.style.paddingRight;\n      document.body.style.paddingRight = scrollBarGap + 'px';\n    }\n  }\n\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n  }\n};\nvar restoreOverflowSetting = function restoreOverflowSetting() {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight;\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined;\n  }\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting;\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined;\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nvar isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {\n  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\n};\nvar handleScroll = function handleScroll(event, targetElement) {\n  var clientY = event.targetTouches[0].clientY - initialClientY;\n  if (allowTouchMove(event.target)) {\n    return false;\n  }\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event);\n  }\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event);\n  }\n  event.stopPropagation();\n  return true;\n};\nvar disableBodyScroll = function disableBodyScroll(targetElement, options) {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');\n    return;\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(function (lock) {\n    return lock.targetElement === targetElement;\n  })) {\n    return;\n  }\n  var lock = {\n    targetElement: targetElement,\n    options: options || {}\n  };\n  locks = [].concat(_toConsumableArray(locks), [lock]);\n  if (isIosDevice) {\n    targetElement.ontouchstart = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY;\n      }\n    };\n    targetElement.ontouchmove = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement);\n      }\n    };\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : undefined);\n      documentListenerAdded = true;\n    }\n  } else {\n    setOverflowHidden(options);\n  }\n};\nvar clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references.\n    locks.forEach(function (lock) {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n    if (documentListenerAdded) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : undefined);\n      documentListenerAdded = false;\n    }\n\n    // Reset initial clientY.\n    initialClientY = -1;\n  } else {\n    restoreOverflowSetting();\n  }\n  locks = [];\n};\nvar enableBodyScroll = function enableBodyScroll(targetElement) {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');\n    return;\n  }\n  locks = locks.filter(function (lock) {\n    return lock.targetElement !== targetElement;\n  });\n  if (isIosDevice) {\n    targetElement.ontouchstart = null;\n    targetElement.ontouchmove = null;\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : undefined);\n      documentListenerAdded = false;\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting();\n  }\n};\n\n//# sourceURL=webpack://inheart/./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js?");

/***/ }),

/***/ "./node_modules/cropperjs/dist/cropper.js":
/*!************************************************!*\
  !*** ./node_modules/cropperjs/dist/cropper.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; return _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof2(obj); }\n/*!\n * Cropper.js v1.5.13\n * https://fengyuanchen.github.io/cropperjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2022-11-20T05:30:46.114Z\n */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof2(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n    return target;\n  }\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  var WINDOW = IS_BROWSER ? window : {};\n  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;\n  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\n  var NAMESPACE = 'cropper';\n\n  // Actions\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n\n  // Classes\n  var CLASS_CROP = \"\".concat(NAMESPACE, \"-crop\");\n  var CLASS_DISABLED = \"\".concat(NAMESPACE, \"-disabled\");\n  var CLASS_HIDDEN = \"\".concat(NAMESPACE, \"-hidden\");\n  var CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\n  var CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\n  var CLASS_MODAL = \"\".concat(NAMESPACE, \"-modal\");\n  var CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\");\n\n  // Data keys\n  var DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n  var DATA_PREVIEW = \"\".concat(NAMESPACE, \"Preview\");\n\n  // Drag modes\n  var DRAG_MODE_CROP = 'crop';\n  var DRAG_MODE_MOVE = 'move';\n  var DRAG_MODE_NONE = 'none';\n\n  // Events\n  var EVENT_CROP = 'crop';\n  var EVENT_CROP_END = 'cropend';\n  var EVENT_CROP_MOVE = 'cropmove';\n  var EVENT_CROP_START = 'cropstart';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\n  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\n  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\n  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\n  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\n  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\n  var EVENT_READY = 'ready';\n  var EVENT_RESIZE = 'resize';\n  var EVENT_WHEEL = 'wheel';\n  var EVENT_ZOOM = 'zoom';\n\n  // Mime types\n  var MIME_TYPE_JPEG = 'image/jpeg';\n\n  // RegExps\n  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;\n  var REGEXP_DATA_URL = /^data:/;\n  var REGEXP_DATA_URL_JPEG = /^data:image\\/jpeg;base64,/;\n  var REGEXP_TAG_NAME = /^img|canvas$/i;\n\n  // Misc\n  // Inspired by the default width and height of a canvas element.\n  var MIN_CONTAINER_WIDTH = 200;\n  var MIN_CONTAINER_HEIGHT = 100;\n  var DEFAULTS = {\n    // Define the view mode of the cropper\n    viewMode: 0,\n    // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: DRAG_MODE_CROP,\n    // 'crop', 'move' or 'none'\n\n    // Define the initial aspect ratio of the crop box\n    initialAspectRatio: NaN,\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n    // An object with the previous cropping result data\n    data: null,\n    // A selector for adding extra containers to preview\n    preview: '',\n    // Re-render the cropper when resize the window\n    responsive: true,\n    // Restore the cropped area after resize the window\n    restore: true,\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n    // Show the black modal\n    modal: true,\n    // Show the dashed lines for guiding\n    guides: true,\n    // Show the center indicator for guiding\n    center: true,\n    // Show the white modal to highlight the crop box\n    highlight: true,\n    // Show the grid background\n    background: true,\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n    // Enable to move the image\n    movable: true,\n    // Enable to rotate the image\n    rotatable: true,\n    // Enable to scale the image\n    scalable: true,\n    // Enable to zoom the image\n    zoomable: true,\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n    // Enable to move the crop box\n    cropBoxMovable: true,\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: MIN_CONTAINER_WIDTH,\n    minContainerHeight: MIN_CONTAINER_HEIGHT,\n    // Shortcuts of events\n    ready: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n  var TEMPLATE = '<div class=\"cropper-container\" touch-action=\"none\">' + '<div class=\"cropper-wrap-box\">' + '<div class=\"cropper-canvas\"></div>' + '</div>' + '<div class=\"cropper-drag-box\"></div>' + '<div class=\"cropper-crop-box\">' + '<span class=\"cropper-view-box\"></span>' + '<span class=\"cropper-dashed dashed-h\"></span>' + '<span class=\"cropper-dashed dashed-v\"></span>' + '<span class=\"cropper-center\"></span>' + '<span class=\"cropper-face\"></span>' + '<span class=\"cropper-line line-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-line line-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-line line-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-line line-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-e\" data-cropper-action=\"e\"></span>' + '<span class=\"cropper-point point-n\" data-cropper-action=\"n\"></span>' + '<span class=\"cropper-point point-w\" data-cropper-action=\"w\"></span>' + '<span class=\"cropper-point point-s\" data-cropper-action=\"s\"></span>' + '<span class=\"cropper-point point-ne\" data-cropper-action=\"ne\"></span>' + '<span class=\"cropper-point point-nw\" data-cropper-action=\"nw\"></span>' + '<span class=\"cropper-point point-sw\" data-cropper-action=\"sw\"></span>' + '<span class=\"cropper-point point-se\" data-cropper-action=\"se\"></span>' + '</div>' + '</div>';\n\n  /**\n   * Check if the given value is not a number.\n   */\n  var isNaN = Number.isNaN || WINDOW.isNaN;\n\n  /**\n   * Check if the given value is a number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n   */\n  function isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n  }\n\n  /**\n   * Check if the given value is a positive number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n   */\n  var isPositiveNumber = function isPositiveNumber(value) {\n    return value > 0 && value < Infinity;\n  };\n\n  /**\n   * Check if the given value is undefined.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n   */\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  /**\n   * Check if the given value is an object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n   */\n  function isObject(value) {\n    return _typeof(value) === 'object' && value !== null;\n  }\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\n   * Check if the given value is a plain object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n   */\n  function isPlainObject(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    try {\n      var _constructor = value.constructor;\n      var prototype = _constructor.prototype;\n      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Check if the given value is a function.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n   */\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  var slice = Array.prototype.slice;\n\n  /**\n   * Convert array-like or iterable object to an array.\n   * @param {*} value - The value to convert.\n   * @returns {Array} Returns a new array.\n   */\n  function toArray(value) {\n    return Array.from ? Array.from(value) : slice.call(value);\n  }\n\n  /**\n   * Iterate the given data.\n   * @param {*} data - The data to iterate.\n   * @param {Function} callback - The process function for each element.\n   * @returns {*} The original data.\n   */\n  function forEach(data, callback) {\n    if (data && isFunction(callback)) {\n      if (Array.isArray(data) || isNumber(data.length) /* array-like */) {\n        toArray(data).forEach(function (value, key) {\n          callback.call(data, value, key, data);\n        });\n      } else if (isObject(data)) {\n        Object.keys(data).forEach(function (key) {\n          callback.call(data, data[key], key, data);\n        });\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Extend the given object.\n   * @param {*} target - The target object to extend.\n   * @param {*} args - The rest objects for merging to the target object.\n   * @returns {Object} The extended object.\n   */\n  var assign = Object.assign || function assign(target) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (isObject(target) && args.length > 0) {\n      args.forEach(function (arg) {\n        if (isObject(arg)) {\n          Object.keys(arg).forEach(function (key) {\n            target[key] = arg[key];\n          });\n        }\n      });\n    }\n    return target;\n  };\n  var REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n\n  /**\n   * Normalize decimal number.\n   * Check out {@link https://0.30000000000000004.com/}\n   * @param {number} value - The value to normalize.\n   * @param {number} [times=100000000000] - The times for normalizing.\n   * @returns {number} Returns the normalized number.\n   */\n  function normalizeDecimalNumber(value) {\n    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n  }\n  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;\n\n  /**\n   * Apply styles to the given element.\n   * @param {Element} element - The target element.\n   * @param {Object} styles - The styles for applying.\n   */\n  function setStyle(element, styles) {\n    var style = element.style;\n    forEach(styles, function (value, property) {\n      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n        value = \"\".concat(value, \"px\");\n      }\n      style[property] = value;\n    });\n  }\n\n  /**\n   * Check if the given element has a special class.\n   * @param {Element} element - The element to check.\n   * @param {string} value - The class to search.\n   * @returns {boolean} Returns `true` if the special class was found.\n   */\n  function hasClass(element, value) {\n    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n  }\n\n  /**\n   * Add classes to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be added.\n   */\n  function addClass(element, value) {\n    if (!value) {\n      return;\n    }\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        addClass(elem, value);\n      });\n      return;\n    }\n    if (element.classList) {\n      element.classList.add(value);\n      return;\n    }\n    var className = element.className.trim();\n    if (!className) {\n      element.className = value;\n    } else if (className.indexOf(value) < 0) {\n      element.className = \"\".concat(className, \" \").concat(value);\n    }\n  }\n\n  /**\n   * Remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be removed.\n   */\n  function removeClass(element, value) {\n    if (!value) {\n      return;\n    }\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        removeClass(elem, value);\n      });\n      return;\n    }\n    if (element.classList) {\n      element.classList.remove(value);\n      return;\n    }\n    if (element.className.indexOf(value) >= 0) {\n      element.className = element.className.replace(value, '');\n    }\n  }\n\n  /**\n   * Add or remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be toggled.\n   * @param {boolean} added - Add only.\n   */\n  function toggleClass(element, value, added) {\n    if (!value) {\n      return;\n    }\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        toggleClass(elem, value, added);\n      });\n      return;\n    }\n\n    // IE10-11 doesn't support the second parameter of `classList.toggle`\n    if (added) {\n      addClass(element, value);\n    } else {\n      removeClass(element, value);\n    }\n  }\n  var REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\n\n  /**\n   * Transform the given string from camelCase to kebab-case\n   * @param {string} value - The value to transform.\n   * @returns {string} The transformed value.\n   */\n  function toParamCase(value) {\n    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();\n  }\n\n  /**\n   * Get data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to get.\n   * @returns {string} The data value.\n   */\n  function getData(element, name) {\n    if (isObject(element[name])) {\n      return element[name];\n    }\n    if (element.dataset) {\n      return element.dataset[name];\n    }\n    return element.getAttribute(\"data-\".concat(toParamCase(name)));\n  }\n\n  /**\n   * Set data to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to set.\n   * @param {string} data - The data value.\n   */\n  function setData(element, name, data) {\n    if (isObject(data)) {\n      element[name] = data;\n    } else if (element.dataset) {\n      element.dataset[name] = data;\n    } else {\n      element.setAttribute(\"data-\".concat(toParamCase(name)), data);\n    }\n  }\n\n  /**\n   * Remove data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to remove.\n   */\n  function removeData(element, name) {\n    if (isObject(element[name])) {\n      try {\n        delete element[name];\n      } catch (error) {\n        element[name] = undefined;\n      }\n    } else if (element.dataset) {\n      // #128 Safari not allows to delete dataset property\n      try {\n        delete element.dataset[name];\n      } catch (error) {\n        element.dataset[name] = undefined;\n      }\n    } else {\n      element.removeAttribute(\"data-\".concat(toParamCase(name)));\n    }\n  }\n  var REGEXP_SPACES = /\\s\\s*/;\n  var onceSupported = function () {\n    var supported = false;\n    if (IS_BROWSER) {\n      var once = false;\n      var listener = function listener() {};\n      var options = Object.defineProperty({}, 'once', {\n        get: function get() {\n          supported = true;\n          return once;\n        },\n        /**\n         * This setter can fix a `TypeError` in strict mode\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n         * @param {boolean} value - The value to set\n         */\n        set: function set(value) {\n          once = value;\n        }\n      });\n      WINDOW.addEventListener('test', listener, options);\n      WINDOW.removeEventListener('test', listener, options);\n    }\n    return supported;\n  }();\n\n  /**\n   * Remove event listener from the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n  function removeListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (!onceSupported) {\n        var listeners = element.listeners;\n        if (listeners && listeners[event] && listeners[event][listener]) {\n          handler = listeners[event][listener];\n          delete listeners[event][listener];\n          if (Object.keys(listeners[event]).length === 0) {\n            delete listeners[event];\n          }\n          if (Object.keys(listeners).length === 0) {\n            delete element.listeners;\n          }\n        }\n      }\n      element.removeEventListener(event, handler, options);\n    });\n  }\n\n  /**\n   * Add event listener to the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n  function addListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (options.once && !onceSupported) {\n        var _element$listeners = element.listeners,\n          listeners = _element$listeners === void 0 ? {} : _element$listeners;\n        _handler = function handler() {\n          delete listeners[event][listener];\n          element.removeEventListener(event, _handler, options);\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n          listener.apply(element, args);\n        };\n        if (!listeners[event]) {\n          listeners[event] = {};\n        }\n        if (listeners[event][listener]) {\n          element.removeEventListener(event, listeners[event][listener], options);\n        }\n        listeners[event][listener] = _handler;\n        element.listeners = listeners;\n      }\n      element.addEventListener(event, _handler, options);\n    });\n  }\n\n  /**\n   * Dispatch event on the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Object} data - The additional event data.\n   * @returns {boolean} Indicate if the event is default prevented or not.\n   */\n  function dispatchEvent(element, type, data) {\n    var event;\n\n    // Event and CustomEvent on IE9-11 are global objects, not constructors\n    if (isFunction(Event) && isFunction(CustomEvent)) {\n      event = new CustomEvent(type, {\n        detail: data,\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent(type, true, true, data);\n    }\n    return element.dispatchEvent(event);\n  }\n\n  /**\n   * Get the offset base on the document.\n   * @param {Element} element - The target element.\n   * @returns {Object} The offset data.\n   */\n  function getOffset(element) {\n    var box = element.getBoundingClientRect();\n    return {\n      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n      top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n    };\n  }\n  var location = WINDOW.location;\n  var REGEXP_ORIGINS = /^(\\w+:)\\/\\/([^:/?#]*):?(\\d*)/i;\n\n  /**\n   * Check if the given URL is a cross origin URL.\n   * @param {string} url - The target URL.\n   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.\n   */\n  function isCrossOriginURL(url) {\n    var parts = url.match(REGEXP_ORIGINS);\n    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);\n  }\n\n  /**\n   * Add timestamp to the given URL.\n   * @param {string} url - The target URL.\n   * @returns {string} The result URL.\n   */\n  function addTimestamp(url) {\n    var timestamp = \"timestamp=\".concat(new Date().getTime());\n    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;\n  }\n\n  /**\n   * Get transforms base on the given object.\n   * @param {Object} obj - The target object.\n   * @returns {string} A string contains transform values.\n   */\n  function getTransforms(_ref) {\n    var rotate = _ref.rotate,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      translateX = _ref.translateX,\n      translateY = _ref.translateY;\n    var values = [];\n    if (isNumber(translateX) && translateX !== 0) {\n      values.push(\"translateX(\".concat(translateX, \"px)\"));\n    }\n    if (isNumber(translateY) && translateY !== 0) {\n      values.push(\"translateY(\".concat(translateY, \"px)\"));\n    }\n\n    // Rotate should come first before scale to match orientation transform\n    if (isNumber(rotate) && rotate !== 0) {\n      values.push(\"rotate(\".concat(rotate, \"deg)\"));\n    }\n    if (isNumber(scaleX) && scaleX !== 1) {\n      values.push(\"scaleX(\".concat(scaleX, \")\"));\n    }\n    if (isNumber(scaleY) && scaleY !== 1) {\n      values.push(\"scaleY(\".concat(scaleY, \")\"));\n    }\n    var transform = values.length ? values.join(' ') : 'none';\n    return {\n      WebkitTransform: transform,\n      msTransform: transform,\n      transform: transform\n    };\n  }\n\n  /**\n   * Get the max ratio of a group of pointers.\n   * @param {string} pointers - The target pointers.\n   * @returns {number} The result ratio.\n   */\n  function getMaxZoomRatio(pointers) {\n    var pointers2 = _objectSpread2({}, pointers);\n    var maxRatio = 0;\n    forEach(pointers, function (pointer, pointerId) {\n      delete pointers2[pointerId];\n      forEach(pointers2, function (pointer2) {\n        var x1 = Math.abs(pointer.startX - pointer2.startX);\n        var y1 = Math.abs(pointer.startY - pointer2.startY);\n        var x2 = Math.abs(pointer.endX - pointer2.endX);\n        var y2 = Math.abs(pointer.endY - pointer2.endY);\n        var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n        var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n        var ratio = (z2 - z1) / z1;\n        if (Math.abs(ratio) > Math.abs(maxRatio)) {\n          maxRatio = ratio;\n        }\n      });\n    });\n    return maxRatio;\n  }\n\n  /**\n   * Get a pointer from an event object.\n   * @param {Object} event - The target event object.\n   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n   * @returns {Object} The result pointer contains start and/or end point coordinates.\n   */\n  function getPointer(_ref2, endOnly) {\n    var pageX = _ref2.pageX,\n      pageY = _ref2.pageY;\n    var end = {\n      endX: pageX,\n      endY: pageY\n    };\n    return endOnly ? end : _objectSpread2({\n      startX: pageX,\n      startY: pageY\n    }, end);\n  }\n\n  /**\n   * Get the center point coordinate of a group of pointers.\n   * @param {Object} pointers - The target pointers.\n   * @returns {Object} The center point coordinate.\n   */\n  function getPointersCenter(pointers) {\n    var pageX = 0;\n    var pageY = 0;\n    var count = 0;\n    forEach(pointers, function (_ref3) {\n      var startX = _ref3.startX,\n        startY = _ref3.startY;\n      pageX += startX;\n      pageY += startY;\n      count += 1;\n    });\n    pageX /= count;\n    pageY /= count;\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  /**\n   * Get the max sizes in a rectangle under the given aspect ratio.\n   * @param {Object} data - The original sizes.\n   * @param {string} [type='contain'] - The adjust type.\n   * @returns {Object} The result sizes.\n   */\n  function getAdjustedSizes(_ref4) {\n    var aspectRatio = _ref4.aspectRatio,\n      height = _ref4.height,\n      width = _ref4.width;\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';\n    var isValidWidth = isPositiveNumber(width);\n    var isValidHeight = isPositiveNumber(height);\n    if (isValidWidth && isValidHeight) {\n      var adjustedWidth = height * aspectRatio;\n      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n        height = width / aspectRatio;\n      } else {\n        width = height * aspectRatio;\n      }\n    } else if (isValidWidth) {\n      height = width / aspectRatio;\n    } else if (isValidHeight) {\n      width = height * aspectRatio;\n    }\n    return {\n      width: width,\n      height: height\n    };\n  }\n\n  /**\n   * Get the new sizes of a rectangle after rotated.\n   * @param {Object} data - The original sizes.\n   * @returns {Object} The result sizes.\n   */\n  function getRotatedSizes(_ref5) {\n    var width = _ref5.width,\n      height = _ref5.height,\n      degree = _ref5.degree;\n    degree = Math.abs(degree) % 180;\n    if (degree === 90) {\n      return {\n        width: height,\n        height: width\n      };\n    }\n    var arc = degree % 90 * Math.PI / 180;\n    var sinArc = Math.sin(arc);\n    var cosArc = Math.cos(arc);\n    var newWidth = width * cosArc + height * sinArc;\n    var newHeight = width * sinArc + height * cosArc;\n    return degree > 90 ? {\n      width: newHeight,\n      height: newWidth\n    } : {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  /**\n   * Get a canvas which drew the given image.\n   * @param {HTMLImageElement} image - The image for drawing.\n   * @param {Object} imageData - The image data.\n   * @param {Object} canvasData - The canvas data.\n   * @param {Object} options - The options.\n   * @returns {HTMLCanvasElement} The result canvas.\n   */\n  function getSourceCanvas(image, _ref6, _ref7, _ref8) {\n    var imageAspectRatio = _ref6.aspectRatio,\n      imageNaturalWidth = _ref6.naturalWidth,\n      imageNaturalHeight = _ref6.naturalHeight,\n      _ref6$rotate = _ref6.rotate,\n      rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,\n      _ref6$scaleX = _ref6.scaleX,\n      scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,\n      _ref6$scaleY = _ref6.scaleY,\n      scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;\n    var aspectRatio = _ref7.aspectRatio,\n      naturalWidth = _ref7.naturalWidth,\n      naturalHeight = _ref7.naturalHeight;\n    var _ref8$fillColor = _ref8.fillColor,\n      fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,\n      _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,\n      imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,\n      _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,\n      imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,\n      _ref8$maxWidth = _ref8.maxWidth,\n      maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,\n      _ref8$maxHeight = _ref8.maxHeight,\n      maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,\n      _ref8$minWidth = _ref8.minWidth,\n      minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,\n      _ref8$minHeight = _ref8.minHeight,\n      minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    var maxSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var minSizes = getAdjustedSizes({\n      aspectRatio: aspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));\n    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));\n\n    // Note: should always use image's natural sizes for drawing as\n    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90\n    var destMaxSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: maxWidth,\n      height: maxHeight\n    });\n    var destMinSizes = getAdjustedSizes({\n      aspectRatio: imageAspectRatio,\n      width: minWidth,\n      height: minHeight\n    }, 'cover');\n    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));\n    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));\n    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];\n    canvas.width = normalizeDecimalNumber(width);\n    canvas.height = normalizeDecimalNumber(height);\n    context.fillStyle = fillColor;\n    context.fillRect(0, 0, width, height);\n    context.save();\n    context.translate(width / 2, height / 2);\n    context.rotate(rotate * Math.PI / 180);\n    context.scale(scaleX, scaleY);\n    context.imageSmoothingEnabled = imageSmoothingEnabled;\n    context.imageSmoothingQuality = imageSmoothingQuality;\n    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {\n      return Math.floor(normalizeDecimalNumber(param));\n    }))));\n    context.restore();\n    return canvas;\n  }\n  var fromCharCode = String.fromCharCode;\n\n  /**\n   * Get string from char code in data view.\n   * @param {DataView} dataView - The data view for read.\n   * @param {number} start - The start index.\n   * @param {number} length - The read length.\n   * @returns {string} The read result.\n   */\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    length += start;\n    for (var i = start; i < length; i += 1) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n    return str;\n  }\n  var REGEXP_DATA_URL_HEAD = /^data:.*,/;\n\n  /**\n   * Transform Data URL to array buffer.\n   * @param {string} dataURL - The Data URL to transform.\n   * @returns {ArrayBuffer} The result array buffer.\n   */\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var arrayBuffer = new ArrayBuffer(binary.length);\n    var uint8 = new Uint8Array(arrayBuffer);\n    forEach(uint8, function (value, i) {\n      uint8[i] = binary.charCodeAt(i);\n    });\n    return arrayBuffer;\n  }\n\n  /**\n   * Transform array buffer to Data URL.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n   * @param {string} mimeType - The mime type of the Data URL.\n   * @returns {string} The result Data URL.\n   */\n  function arrayBufferToDataURL(arrayBuffer, mimeType) {\n    var chunks = [];\n\n    // Chunk Typed Array for better performance (#435)\n    var chunkSize = 8192;\n    var uint8 = new Uint8Array(arrayBuffer);\n    while (uint8.length > 0) {\n      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n      // eslint-disable-next-line prefer-spread\n      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n      uint8 = uint8.subarray(chunkSize);\n    }\n    return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\n  }\n\n  /**\n   * Get orientation value from given array buffer.\n   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n   * @returns {number} The read orientation value.\n   */\n  function resetAndGetOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var orientation;\n\n    // Ignores range error when the image does not have correct Exif information\n    try {\n      var littleEndian;\n      var app1Start;\n      var ifdStart;\n\n      // Only handle JPEG image (start by 0xFFD8)\n      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n        var length = dataView.byteLength;\n        var offset = 2;\n        while (offset + 1 < length) {\n          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n            app1Start = offset;\n            break;\n          }\n          offset += 1;\n        }\n      }\n      if (app1Start) {\n        var exifIDCode = app1Start + 4;\n        var tiffOffset = app1Start + 10;\n        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n          var endianness = dataView.getUint16(tiffOffset);\n          littleEndian = endianness === 0x4949;\n          if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n            if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n              var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n              if (firstIFDOffset >= 0x00000008) {\n                ifdStart = tiffOffset + firstIFDOffset;\n              }\n            }\n          }\n        }\n      }\n      if (ifdStart) {\n        var _length = dataView.getUint16(ifdStart, littleEndian);\n        var _offset;\n        var i;\n        for (i = 0; i < _length; i += 1) {\n          _offset = ifdStart + i * 12 + 2;\n          if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {\n            // 8 is the offset of the current tag's value\n            _offset += 8;\n\n            // Get the original orientation value\n            orientation = dataView.getUint16(_offset, littleEndian);\n\n            // Override the orientation with its default value\n            dataView.setUint16(_offset, 1, littleEndian);\n            break;\n          }\n        }\n      }\n    } catch (error) {\n      orientation = 1;\n    }\n    return orientation;\n  }\n\n  /**\n   * Parse Exif Orientation value.\n   * @param {number} orientation - The orientation to parse.\n   * @returns {Object} The parsed result.\n   */\n  function parseOrientation(orientation) {\n    var rotate = 0;\n    var scaleX = 1;\n    var scaleY = 1;\n    switch (orientation) {\n      // Flip horizontal\n      case 2:\n        scaleX = -1;\n        break;\n\n      // Rotate left 180°\n      case 3:\n        rotate = -180;\n        break;\n\n      // Flip vertical\n      case 4:\n        scaleY = -1;\n        break;\n\n      // Flip vertical and rotate right 90°\n      case 5:\n        rotate = 90;\n        scaleY = -1;\n        break;\n\n      // Rotate right 90°\n      case 6:\n        rotate = 90;\n        break;\n\n      // Flip horizontal and rotate right 90°\n      case 7:\n        rotate = 90;\n        scaleX = -1;\n        break;\n\n      // Rotate left 90°\n      case 8:\n        rotate = -90;\n        break;\n    }\n    return {\n      rotate: rotate,\n      scaleX: scaleX,\n      scaleY: scaleY\n    };\n  }\n  var render = {\n    render: function render() {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n      this.renderCanvas();\n      if (this.cropped) {\n        this.renderCropBox();\n      }\n    },\n    initContainer: function initContainer() {\n      var element = this.element,\n        options = this.options,\n        container = this.container,\n        cropper = this.cropper;\n      var minWidth = Number(options.minContainerWidth);\n      var minHeight = Number(options.minContainerHeight);\n      addClass(cropper, CLASS_HIDDEN);\n      removeClass(element, CLASS_HIDDEN);\n      var containerData = {\n        width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),\n        height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)\n      };\n      this.containerData = containerData;\n      setStyle(cropper, {\n        width: containerData.width,\n        height: containerData.height\n      });\n      addClass(element, CLASS_HIDDEN);\n      removeClass(cropper, CLASS_HIDDEN);\n    },\n    // Canvas (image wrapper)\n    initCanvas: function initCanvas() {\n      var containerData = this.containerData,\n        imageData = this.imageData;\n      var viewMode = this.options.viewMode;\n      var rotated = Math.abs(imageData.rotate) % 180 === 90;\n      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;\n      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerData.width;\n      var canvasHeight = containerData.height;\n      if (containerData.height * aspectRatio > containerData.width) {\n        if (viewMode === 3) {\n          canvasWidth = containerData.height * aspectRatio;\n        } else {\n          canvasHeight = containerData.width / aspectRatio;\n        }\n      } else if (viewMode === 3) {\n        canvasHeight = containerData.width / aspectRatio;\n      } else {\n        canvasWidth = containerData.height * aspectRatio;\n      }\n      var canvasData = {\n        aspectRatio: aspectRatio,\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n      this.canvasData = canvasData;\n      this.limited = viewMode === 1 || viewMode === 2;\n      this.limitCanvas(true, true);\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n      canvasData.left = (containerData.width - canvasData.width) / 2;\n      canvasData.top = (containerData.height - canvasData.height) / 2;\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      this.initialCanvasData = assign({}, canvasData);\n    },\n    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {\n      var options = this.options,\n        containerData = this.containerData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n      var viewMode = options.viewMode;\n      var aspectRatio = canvasData.aspectRatio;\n      var cropped = this.cropped && cropBoxData;\n      if (sizeLimited) {\n        var minCanvasWidth = Number(options.minCanvasWidth) || 0;\n        var minCanvasHeight = Number(options.minCanvasHeight) || 0;\n        if (viewMode > 1) {\n          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);\n          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);\n          if (viewMode === 3) {\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        } else if (viewMode > 0) {\n          if (minCanvasWidth) {\n            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);\n          } else if (minCanvasHeight) {\n            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);\n          } else if (cropped) {\n            minCanvasWidth = cropBoxData.width;\n            minCanvasHeight = cropBoxData.height;\n            if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n              minCanvasWidth = minCanvasHeight * aspectRatio;\n            } else {\n              minCanvasHeight = minCanvasWidth / aspectRatio;\n            }\n          }\n        }\n        var _getAdjustedSizes = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: minCanvasWidth,\n          height: minCanvasHeight\n        });\n        minCanvasWidth = _getAdjustedSizes.width;\n        minCanvasHeight = _getAdjustedSizes.height;\n        canvasData.minWidth = minCanvasWidth;\n        canvasData.minHeight = minCanvasHeight;\n        canvasData.maxWidth = Infinity;\n        canvasData.maxHeight = Infinity;\n      }\n      if (positionLimited) {\n        if (viewMode > (cropped ? 0 : 1)) {\n          var newCanvasLeft = containerData.width - canvasData.width;\n          var newCanvasTop = containerData.height - canvasData.height;\n          canvasData.minLeft = Math.min(0, newCanvasLeft);\n          canvasData.minTop = Math.min(0, newCanvasTop);\n          canvasData.maxLeft = Math.max(0, newCanvasLeft);\n          canvasData.maxTop = Math.max(0, newCanvasTop);\n          if (cropped && this.limited) {\n            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));\n            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));\n            canvasData.maxLeft = cropBoxData.left;\n            canvasData.maxTop = cropBoxData.top;\n            if (viewMode === 2) {\n              if (canvasData.width >= containerData.width) {\n                canvasData.minLeft = Math.min(0, newCanvasLeft);\n                canvasData.maxLeft = Math.max(0, newCanvasLeft);\n              }\n              if (canvasData.height >= containerData.height) {\n                canvasData.minTop = Math.min(0, newCanvasTop);\n                canvasData.maxTop = Math.max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvasData.minLeft = -canvasData.width;\n          canvasData.minTop = -canvasData.height;\n          canvasData.maxLeft = containerData.width;\n          canvasData.maxTop = containerData.height;\n        }\n      }\n    },\n    renderCanvas: function renderCanvas(changed, transformed) {\n      var canvasData = this.canvasData,\n        imageData = this.imageData;\n      if (transformed) {\n        var _getRotatedSizes = getRotatedSizes({\n            width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),\n            height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),\n            degree: imageData.rotate || 0\n          }),\n          naturalWidth = _getRotatedSizes.width,\n          naturalHeight = _getRotatedSizes.height;\n        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);\n        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);\n        canvasData.left -= (width - canvasData.width) / 2;\n        canvasData.top -= (height - canvasData.height) / 2;\n        canvasData.width = width;\n        canvasData.height = height;\n        canvasData.aspectRatio = naturalWidth / naturalHeight;\n        canvasData.naturalWidth = naturalWidth;\n        canvasData.naturalHeight = naturalHeight;\n        this.limitCanvas(true, false);\n      }\n      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {\n        canvasData.left = canvasData.oldLeft;\n      }\n      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {\n        canvasData.top = canvasData.oldTop;\n      }\n      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);\n      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);\n      this.limitCanvas(false, true);\n      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);\n      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);\n      canvasData.oldLeft = canvasData.left;\n      canvasData.oldTop = canvasData.top;\n      setStyle(this.canvas, assign({\n        width: canvasData.width,\n        height: canvasData.height\n      }, getTransforms({\n        translateX: canvasData.left,\n        translateY: canvasData.top\n      })));\n      this.renderImage(changed);\n      if (this.cropped && this.limited) {\n        this.limitCropBox(true, true);\n      }\n    },\n    renderImage: function renderImage(changed) {\n      var canvasData = this.canvasData,\n        imageData = this.imageData;\n      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);\n      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);\n      assign(imageData, {\n        width: width,\n        height: height,\n        left: (canvasData.width - width) / 2,\n        top: (canvasData.height - height) / 2\n      });\n      setStyle(this.image, assign({\n        width: imageData.width,\n        height: imageData.height\n      }, getTransforms(assign({\n        translateX: imageData.left,\n        translateY: imageData.top\n      }, imageData))));\n      if (changed) {\n        this.output();\n      }\n    },\n    initCropBox: function initCropBox() {\n      var options = this.options,\n        canvasData = this.canvasData;\n      var aspectRatio = options.aspectRatio || options.initialAspectRatio;\n      var autoCropArea = Number(options.autoCropArea) || 0.8;\n      var cropBoxData = {\n        width: canvasData.width,\n        height: canvasData.height\n      };\n      if (aspectRatio) {\n        if (canvasData.height * aspectRatio > canvasData.width) {\n          cropBoxData.height = cropBoxData.width / aspectRatio;\n        } else {\n          cropBoxData.width = cropBoxData.height * aspectRatio;\n        }\n      }\n      this.cropBoxData = cropBoxData;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n\n      // The width/height of auto crop area must large than \"minWidth/Height\"\n      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);\n      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);\n      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;\n      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n      this.initialCropBoxData = assign({}, cropBoxData);\n    },\n    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {\n      var options = this.options,\n        containerData = this.containerData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData,\n        limited = this.limited;\n      var aspectRatio = options.aspectRatio;\n      if (sizeLimited) {\n        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;\n        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;\n        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;\n        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;\n\n        // The min/maxCropBoxWidth/Height must be less than container's width/height\n        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);\n        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);\n        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);\n        cropBoxData.maxWidth = maxCropBoxWidth;\n        cropBoxData.maxHeight = maxCropBoxHeight;\n      }\n      if (positionLimited) {\n        if (limited) {\n          cropBoxData.minLeft = Math.max(0, canvasData.left);\n          cropBoxData.minTop = Math.max(0, canvasData.top);\n          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;\n          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;\n        } else {\n          cropBoxData.minLeft = 0;\n          cropBoxData.minTop = 0;\n          cropBoxData.maxLeft = containerData.width - cropBoxData.width;\n          cropBoxData.maxTop = containerData.height - cropBoxData.height;\n        }\n      }\n    },\n    renderCropBox: function renderCropBox() {\n      var options = this.options,\n        containerData = this.containerData,\n        cropBoxData = this.cropBoxData;\n      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {\n        cropBoxData.left = cropBoxData.oldLeft;\n      }\n      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {\n        cropBoxData.top = cropBoxData.oldTop;\n      }\n      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);\n      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);\n      this.limitCropBox(false, true);\n      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);\n      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);\n      cropBoxData.oldLeft = cropBoxData.left;\n      cropBoxData.oldTop = cropBoxData.top;\n      if (options.movable && options.cropBoxMovable) {\n        // Turn to move the canvas when the crop box is equal to the container\n        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);\n      }\n      setStyle(this.cropBox, assign({\n        width: cropBoxData.width,\n        height: cropBoxData.height\n      }, getTransforms({\n        translateX: cropBoxData.left,\n        translateY: cropBoxData.top\n      })));\n      if (this.cropped && this.limited) {\n        this.limitCanvas(true, true);\n      }\n      if (!this.disabled) {\n        this.output();\n      }\n    },\n    output: function output() {\n      this.preview();\n      dispatchEvent(this.element, EVENT_CROP, this.getData());\n    }\n  };\n  var preview = {\n    initPreview: function initPreview() {\n      var element = this.element,\n        crossOrigin = this.crossOrigin;\n      var preview = this.options.preview;\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var alt = element.alt || 'The image to preview';\n      var image = document.createElement('img');\n      if (crossOrigin) {\n        image.crossOrigin = crossOrigin;\n      }\n      image.src = url;\n      image.alt = alt;\n      this.viewBox.appendChild(image);\n      this.viewBoxImage = image;\n      if (!preview) {\n        return;\n      }\n      var previews = preview;\n      if (typeof preview === 'string') {\n        previews = element.ownerDocument.querySelectorAll(preview);\n      } else if (preview.querySelector) {\n        previews = [preview];\n      }\n      this.previews = previews;\n      forEach(previews, function (el) {\n        var img = document.createElement('img');\n\n        // Save the original size for recover\n        setData(el, DATA_PREVIEW, {\n          width: el.offsetWidth,\n          height: el.offsetHeight,\n          html: el.innerHTML\n        });\n        if (crossOrigin) {\n          img.crossOrigin = crossOrigin;\n        }\n        img.src = url;\n        img.alt = alt;\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * Add `height:auto` to override `height` attribute on IE8\n         * (Occur only when margin-top <= -height)\n         */\n        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;\"';\n        el.innerHTML = '';\n        el.appendChild(img);\n      });\n    },\n    resetPreview: function resetPreview() {\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        setStyle(element, {\n          width: data.width,\n          height: data.height\n        });\n        element.innerHTML = data.html;\n        removeData(element, DATA_PREVIEW);\n      });\n    },\n    preview: function preview() {\n      var imageData = this.imageData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n      var cropBoxWidth = cropBoxData.width,\n        cropBoxHeight = cropBoxData.height;\n      var width = imageData.width,\n        height = imageData.height;\n      var left = cropBoxData.left - canvasData.left - imageData.left;\n      var top = cropBoxData.top - canvasData.top - imageData.top;\n      if (!this.cropped || this.disabled) {\n        return;\n      }\n      setStyle(this.viewBoxImage, assign({\n        width: width,\n        height: height\n      }, getTransforms(assign({\n        translateX: -left,\n        translateY: -top\n      }, imageData))));\n      forEach(this.previews, function (element) {\n        var data = getData(element, DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n        setStyle(element, {\n          width: newWidth,\n          height: newHeight\n        });\n        setStyle(element.getElementsByTagName('img')[0], assign({\n          width: width * ratio,\n          height: height * ratio\n        }, getTransforms(assign({\n          translateX: -left * ratio,\n          translateY: -top * ratio\n        }, imageData))));\n      });\n    }\n  };\n  var events = {\n    bind: function bind() {\n      var element = this.element,\n        options = this.options,\n        cropper = this.cropper;\n      if (isFunction(options.cropstart)) {\n        addListener(element, EVENT_CROP_START, options.cropstart);\n      }\n      if (isFunction(options.cropmove)) {\n        addListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n      if (isFunction(options.cropend)) {\n        addListener(element, EVENT_CROP_END, options.cropend);\n      }\n      if (isFunction(options.crop)) {\n        addListener(element, EVENT_CROP, options.crop);\n      }\n      if (isFunction(options.zoom)) {\n        addListener(element, EVENT_ZOOM, options.zoom);\n      }\n      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));\n      if (options.zoomable && options.zoomOnWheel) {\n        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n          passive: false,\n          capture: true\n        });\n      }\n      if (options.toggleDragModeOnDblclick) {\n        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n      }\n      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));\n      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));\n      if (options.responsive) {\n        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n      }\n    },\n    unbind: function unbind() {\n      var element = this.element,\n        options = this.options,\n        cropper = this.cropper;\n      if (isFunction(options.cropstart)) {\n        removeListener(element, EVENT_CROP_START, options.cropstart);\n      }\n      if (isFunction(options.cropmove)) {\n        removeListener(element, EVENT_CROP_MOVE, options.cropmove);\n      }\n      if (isFunction(options.cropend)) {\n        removeListener(element, EVENT_CROP_END, options.cropend);\n      }\n      if (isFunction(options.crop)) {\n        removeListener(element, EVENT_CROP, options.crop);\n      }\n      if (isFunction(options.zoom)) {\n        removeListener(element, EVENT_ZOOM, options.zoom);\n      }\n      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);\n      if (options.zoomable && options.zoomOnWheel) {\n        removeListener(cropper, EVENT_WHEEL, this.onWheel, {\n          passive: false,\n          capture: true\n        });\n      }\n      if (options.toggleDragModeOnDblclick) {\n        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);\n      }\n      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);\n      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);\n      if (options.responsive) {\n        removeListener(window, EVENT_RESIZE, this.onResize);\n      }\n    }\n  };\n  var handlers = {\n    resize: function resize() {\n      if (this.disabled) {\n        return;\n      }\n      var options = this.options,\n        container = this.container,\n        containerData = this.containerData;\n      var ratioX = container.offsetWidth / containerData.width;\n      var ratioY = container.offsetHeight / containerData.height;\n      var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1) {\n        var canvasData;\n        var cropBoxData;\n        if (options.restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n        this.render();\n        if (options.restore) {\n          this.setCanvasData(forEach(canvasData, function (n, i) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData(forEach(cropBoxData, function (n, i) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n    dblclick: function dblclick() {\n      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {\n        return;\n      }\n      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);\n    },\n    wheel: function wheel(event) {\n      var _this = this;\n      var ratio = Number(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n      if (this.disabled) {\n        return;\n      }\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast (#21)\n      if (this.wheeling) {\n        return;\n      }\n      this.wheeling = true;\n      setTimeout(function () {\n        _this.wheeling = false;\n      }, 50);\n      if (event.deltaY) {\n        delta = event.deltaY > 0 ? 1 : -1;\n      } else if (event.wheelDelta) {\n        delta = -event.wheelDelta / 120;\n      } else if (event.detail) {\n        delta = event.detail > 0 ? 1 : -1;\n      }\n      this.zoom(-delta * ratio, event);\n    },\n    cropStart: function cropStart(event) {\n      var buttons = event.buttons,\n        button = event.button;\n      if (this.disabled\n\n      // Handle mouse event and pointer event and ignore touch event\n      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (\n      // No primary button (Usually the left button)\n      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0\n\n      // Open context menu\n      || event.ctrlKey)) {\n        return;\n      }\n      var options = this.options,\n        pointers = this.pointers;\n      var action;\n      if (event.changedTouches) {\n        // Handle touch event\n        forEach(event.changedTouches, function (touch) {\n          pointers[touch.identifier] = getPointer(touch);\n        });\n      } else {\n        // Handle mouse event and pointer event\n        pointers[event.pointerId || 0] = getPointer(event);\n      }\n      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n        action = ACTION_ZOOM;\n      } else {\n        action = getData(event.target, DATA_ACTION);\n      }\n      if (!REGEXP_ACTIONS.test(action)) {\n        return;\n      }\n      if (dispatchEvent(this.element, EVENT_CROP_START, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      }\n\n      // This line is required for preventing page zooming in iOS browsers\n      event.preventDefault();\n      this.action = action;\n      this.cropping = false;\n      if (action === ACTION_CROP) {\n        this.cropping = true;\n        addClass(this.dragBox, CLASS_MODAL);\n      }\n    },\n    cropMove: function cropMove(event) {\n      var action = this.action;\n      if (this.disabled || !action) {\n        return;\n      }\n      var pointers = this.pointers;\n      event.preventDefault();\n      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {\n        originalEvent: event,\n        action: action\n      }) === false) {\n        return;\n      }\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          // The first parameter should not be undefined (#432)\n          assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n        });\n      } else {\n        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n      }\n      this.change(event);\n    },\n    cropEnd: function cropEnd(event) {\n      if (this.disabled) {\n        return;\n      }\n      var action = this.action,\n        pointers = this.pointers;\n      if (event.changedTouches) {\n        forEach(event.changedTouches, function (touch) {\n          delete pointers[touch.identifier];\n        });\n      } else {\n        delete pointers[event.pointerId || 0];\n      }\n      if (!action) {\n        return;\n      }\n      event.preventDefault();\n      if (!Object.keys(pointers).length) {\n        this.action = '';\n      }\n      if (this.cropping) {\n        this.cropping = false;\n        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);\n      }\n      dispatchEvent(this.element, EVENT_CROP_END, {\n        originalEvent: event,\n        action: action\n      });\n    }\n  };\n  var change = {\n    change: function change(event) {\n      var options = this.options,\n        canvasData = this.canvasData,\n        containerData = this.containerData,\n        cropBoxData = this.cropBoxData,\n        pointers = this.pointers;\n      var action = this.action;\n      var aspectRatio = options.aspectRatio;\n      var left = cropBoxData.left,\n        top = cropBoxData.top,\n        width = cropBoxData.width,\n        height = cropBoxData.height;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = containerData.width;\n      var maxHeight = containerData.height;\n      var renderable = true;\n      var offset;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key\n      if (!aspectRatio && event.shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n      if (this.limited) {\n        minLeft = cropBoxData.minLeft;\n        minTop = cropBoxData.minTop;\n        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);\n        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);\n      }\n      var pointer = pointers[Object.keys(pointers)[0]];\n      var range = {\n        x: pointer.endX - pointer.startX,\n        y: pointer.endY - pointer.startY\n      };\n      var check = function check(side) {\n        switch (side) {\n          case ACTION_EAST:\n            if (right + range.x > maxWidth) {\n              range.x = maxWidth - right;\n            }\n            break;\n          case ACTION_WEST:\n            if (left + range.x < minLeft) {\n              range.x = minLeft - left;\n            }\n            break;\n          case ACTION_NORTH:\n            if (top + range.y < minTop) {\n              range.y = minTop - top;\n            }\n            break;\n          case ACTION_SOUTH:\n            if (bottom + range.y > maxHeight) {\n              range.y = maxHeight - bottom;\n            }\n            break;\n        }\n      };\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n          check(ACTION_EAST);\n          width += range.x;\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = -width;\n            left -= width;\n          }\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n          break;\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n          check(ACTION_NORTH);\n          height -= range.y;\n          top += range.y;\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = -height;\n            top -= height;\n          }\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n          break;\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {\n            renderable = false;\n            break;\n          }\n          check(ACTION_WEST);\n          width -= range.x;\n          left += range.x;\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = -width;\n            left -= width;\n          }\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += (cropBoxData.height - height) / 2;\n          }\n          break;\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {\n            renderable = false;\n            break;\n          }\n          check(ACTION_SOUTH);\n          height += range.y;\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = -height;\n            top -= height;\n          }\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += (cropBoxData.width - width) / 2;\n          }\n          break;\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_EAST);\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            top -= height;\n          }\n          break;\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n            check(ACTION_NORTH);\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += cropBoxData.width - width;\n          } else {\n            check(ACTION_NORTH);\n            check(ACTION_WEST);\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = -height;\n            top -= height;\n          }\n          break;\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n            check(ACTION_WEST);\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_WEST);\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            top -= height;\n          }\n          break;\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n            check(ACTION_EAST);\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            check(ACTION_SOUTH);\n            check(ACTION_EAST);\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = -height;\n            width = -width;\n            top -= height;\n            left -= width;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = -width;\n            left -= width;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = -height;\n            top -= height;\n          }\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom(getMaxZoomRatio(pointers), event);\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n          offset = getOffset(this.cropper);\n          left = pointer.startX - offset.left;\n          top = pointer.startY - offset.top;\n          width = cropBoxData.minWidth;\n          height = cropBoxData.minHeight;\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.cropped) {\n            removeClass(this.cropBox, CLASS_HIDDEN);\n            this.cropped = true;\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n          break;\n      }\n      if (renderable) {\n        cropBoxData.width = width;\n        cropBoxData.height = height;\n        cropBoxData.left = left;\n        cropBoxData.top = top;\n        this.action = action;\n        this.renderCropBox();\n      }\n\n      // Override\n      forEach(pointers, function (p) {\n        p.startX = p.endX;\n        p.startY = p.endY;\n      });\n    }\n  };\n  var methods = {\n    // Show the crop box manually\n    crop: function crop() {\n      if (this.ready && !this.cropped && !this.disabled) {\n        this.cropped = true;\n        this.limitCropBox(true, true);\n        if (this.options.modal) {\n          addClass(this.dragBox, CLASS_MODAL);\n        }\n        removeClass(this.cropBox, CLASS_HIDDEN);\n        this.setCropBoxData(this.initialCropBoxData);\n      }\n      return this;\n    },\n    // Reset the image and crop box to their initial states\n    reset: function reset() {\n      if (this.ready && !this.disabled) {\n        this.imageData = assign({}, this.initialImageData);\n        this.canvasData = assign({}, this.initialCanvasData);\n        this.cropBoxData = assign({}, this.initialCropBoxData);\n        this.renderCanvas();\n        if (this.cropped) {\n          this.renderCropBox();\n        }\n      }\n      return this;\n    },\n    // Clear the crop box\n    clear: function clear() {\n      if (this.cropped && !this.disabled) {\n        assign(this.cropBoxData, {\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        });\n        this.cropped = false;\n        this.renderCropBox();\n        this.limitCanvas(true, true);\n\n        // Render canvas after crop box rendered\n        this.renderCanvas();\n        removeClass(this.dragBox, CLASS_MODAL);\n        addClass(this.cropBox, CLASS_HIDDEN);\n      }\n      return this;\n    },\n    /**\n     * Replace the image's src and rebuild the cropper\n     * @param {string} url - The new URL.\n     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.\n     * @returns {Cropper} this\n     */\n    replace: function replace(url) {\n      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!this.disabled && url) {\n        if (this.isImg) {\n          this.element.src = url;\n        }\n        if (hasSameSize) {\n          this.url = url;\n          this.image.src = url;\n          if (this.ready) {\n            this.viewBoxImage.src = url;\n            forEach(this.previews, function (element) {\n              element.getElementsByTagName('img')[0].src = url;\n            });\n          }\n        } else {\n          if (this.isImg) {\n            this.replaced = true;\n          }\n          this.options.data = null;\n          this.uncreate();\n          this.load(url);\n        }\n      }\n      return this;\n    },\n    // Enable (unfreeze) the cropper\n    enable: function enable() {\n      if (this.ready && this.disabled) {\n        this.disabled = false;\n        removeClass(this.cropper, CLASS_DISABLED);\n      }\n      return this;\n    },\n    // Disable (freeze) the cropper\n    disable: function disable() {\n      if (this.ready && !this.disabled) {\n        this.disabled = true;\n        addClass(this.cropper, CLASS_DISABLED);\n      }\n      return this;\n    },\n    /**\n     * Destroy the cropper and remove the instance from the image\n     * @returns {Cropper} this\n     */\n    destroy: function destroy() {\n      var element = this.element;\n      if (!element[NAMESPACE]) {\n        return this;\n      }\n      element[NAMESPACE] = undefined;\n      if (this.isImg && this.replaced) {\n        element.src = this.originalUrl;\n      }\n      this.uncreate();\n      return this;\n    },\n    /**\n     * Move the canvas with relative offsets\n     * @param {number} offsetX - The relative offset distance on the x-axis.\n     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.\n     * @returns {Cropper} this\n     */\n    move: function move(offsetX) {\n      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;\n      var _this$canvasData = this.canvasData,\n        left = _this$canvasData.left,\n        top = _this$canvasData.top;\n      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));\n    },\n    /**\n     * Move the canvas to an absolute point\n     * @param {number} x - The x-axis coordinate.\n     * @param {number} [y=x] - The y-axis coordinate.\n     * @returns {Cropper} this\n     */\n    moveTo: function moveTo(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      var canvasData = this.canvasData;\n      var changed = false;\n      x = Number(x);\n      y = Number(y);\n      if (this.ready && !this.disabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvasData.left = x;\n          changed = true;\n        }\n        if (isNumber(y)) {\n          canvasData.top = y;\n          changed = true;\n        }\n        if (changed) {\n          this.renderCanvas(true);\n        }\n      }\n      return this;\n    },\n    /**\n     * Zoom the canvas with a relative ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoom: function zoom(ratio, _originalEvent) {\n      var canvasData = this.canvasData;\n      ratio = Number(ratio);\n      if (ratio < 0) {\n        ratio = 1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);\n    },\n    /**\n     * Zoom the canvas to an absolute ratio\n     * @param {number} ratio - The target ratio.\n     * @param {Object} pivot - The zoom pivot point coordinate.\n     * @param {Event} _originalEvent - The original event if any.\n     * @returns {Cropper} this\n     */\n    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {\n      var options = this.options,\n        canvasData = this.canvasData;\n      var width = canvasData.width,\n        height = canvasData.height,\n        naturalWidth = canvasData.naturalWidth,\n        naturalHeight = canvasData.naturalHeight;\n      ratio = Number(ratio);\n      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {\n        var newWidth = naturalWidth * ratio;\n        var newHeight = naturalHeight * ratio;\n        if (dispatchEvent(this.element, EVENT_ZOOM, {\n          ratio: ratio,\n          oldRatio: width / naturalWidth,\n          originalEvent: _originalEvent\n        }) === false) {\n          return this;\n        }\n        if (_originalEvent) {\n          var pointers = this.pointers;\n          var offset = getOffset(this.cropper);\n          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n            pageX: _originalEvent.pageX,\n            pageY: _originalEvent.pageY\n          };\n\n          // Zoom from the triggering point of the event\n          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);\n        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);\n          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);\n        } else {\n          // Zoom from the center of the canvas\n          canvasData.left -= (newWidth - width) / 2;\n          canvasData.top -= (newHeight - height) / 2;\n        }\n        canvasData.width = newWidth;\n        canvasData.height = newHeight;\n        this.renderCanvas(true);\n      }\n      return this;\n    },\n    /**\n     * Rotate the canvas with a relative degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotate: function rotate(degree) {\n      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    },\n    /**\n     * Rotate the canvas to an absolute degree\n     * @param {number} degree - The rotate degree.\n     * @returns {Cropper} this\n     */\n    rotateTo: function rotateTo(degree) {\n      degree = Number(degree);\n      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {\n        this.imageData.rotate = degree % 360;\n        this.renderCanvas(true, true);\n      }\n      return this;\n    },\n    /**\n     * Scale the image on the x-axis.\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @returns {Cropper} this\n     */\n    scaleX: function scaleX(_scaleX) {\n      var scaleY = this.imageData.scaleY;\n      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n    /**\n     * Scale the image on the y-axis.\n     * @param {number} scaleY - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scaleY: function scaleY(_scaleY) {\n      var scaleX = this.imageData.scaleX;\n      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);\n    },\n    /**\n     * Scale the image\n     * @param {number} scaleX - The scale ratio on the x-axis.\n     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n     * @returns {Cropper} this\n     */\n    scale: function scale(scaleX) {\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n      var imageData = this.imageData;\n      var transformed = false;\n      scaleX = Number(scaleX);\n      scaleY = Number(scaleY);\n      if (this.ready && !this.disabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          imageData.scaleX = scaleX;\n          transformed = true;\n        }\n        if (isNumber(scaleY)) {\n          imageData.scaleY = scaleY;\n          transformed = true;\n        }\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n      }\n      return this;\n    },\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     * @param {boolean} [rounded=false] - Indicate if round the data values or not.\n     * @returns {Object} The result cropped data.\n     */\n    getData: function getData() {\n      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var options = this.options,\n        imageData = this.imageData,\n        canvasData = this.canvasData,\n        cropBoxData = this.cropBoxData;\n      var data;\n      if (this.ready && this.cropped) {\n        data = {\n          x: cropBoxData.left - canvasData.left,\n          y: cropBoxData.top - canvasData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n        var ratio = imageData.width / imageData.naturalWidth;\n        forEach(data, function (n, i) {\n          data[i] = n / ratio;\n        });\n        if (rounded) {\n          // In case rounding off leads to extra 1px in right or bottom border\n          // we should round the top-left corner and the dimension (#343).\n          var bottom = Math.round(data.y + data.height);\n          var right = Math.round(data.x + data.width);\n          data.x = Math.round(data.x);\n          data.y = Math.round(data.y);\n          data.width = right - data.x;\n          data.height = bottom - data.y;\n        }\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      if (options.rotatable) {\n        data.rotate = imageData.rotate || 0;\n      }\n      if (options.scalable) {\n        data.scaleX = imageData.scaleX || 1;\n        data.scaleY = imageData.scaleY || 1;\n      }\n      return data;\n    },\n    /**\n     * Set the cropped area position and size with new data\n     * @param {Object} data - The new data.\n     * @returns {Cropper} this\n     */\n    setData: function setData(data) {\n      var options = this.options,\n        imageData = this.imageData,\n        canvasData = this.canvasData;\n      var cropBoxData = {};\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        var transformed = false;\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {\n            imageData.rotate = data.rotate;\n            transformed = true;\n          }\n        }\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {\n            imageData.scaleX = data.scaleX;\n            transformed = true;\n          }\n          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {\n            imageData.scaleY = data.scaleY;\n            transformed = true;\n          }\n        }\n        if (transformed) {\n          this.renderCanvas(true, true);\n        }\n        var ratio = imageData.width / imageData.naturalWidth;\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvasData.left;\n        }\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvasData.top;\n        }\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n        this.setCropBoxData(cropBoxData);\n      }\n      return this;\n    },\n    /**\n     * Get the container size data.\n     * @returns {Object} The result container data.\n     */\n    getContainerData: function getContainerData() {\n      return this.ready ? assign({}, this.containerData) : {};\n    },\n    /**\n     * Get the image position and size data.\n     * @returns {Object} The result image data.\n     */\n    getImageData: function getImageData() {\n      return this.sized ? assign({}, this.imageData) : {};\n    },\n    /**\n     * Get the canvas position and size data.\n     * @returns {Object} The result canvas data.\n     */\n    getCanvasData: function getCanvasData() {\n      var canvasData = this.canvasData;\n      var data = {};\n      if (this.ready) {\n        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {\n          data[n] = canvasData[n];\n        });\n      }\n      return data;\n    },\n    /**\n     * Set the canvas position and size with new data.\n     * @param {Object} data - The new canvas data.\n     * @returns {Cropper} this\n     */\n    setCanvasData: function setCanvasData(data) {\n      var canvasData = this.canvasData;\n      var aspectRatio = canvasData.aspectRatio;\n      if (this.ready && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvasData.left = data.left;\n        }\n        if (isNumber(data.top)) {\n          canvasData.top = data.top;\n        }\n        if (isNumber(data.width)) {\n          canvasData.width = data.width;\n          canvasData.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvasData.height = data.height;\n          canvasData.width = data.height * aspectRatio;\n        }\n        this.renderCanvas(true);\n      }\n      return this;\n    },\n    /**\n     * Get the crop box position and size data.\n     * @returns {Object} The result crop box data.\n     */\n    getCropBoxData: function getCropBoxData() {\n      var cropBoxData = this.cropBoxData;\n      var data;\n      if (this.ready && this.cropped) {\n        data = {\n          left: cropBoxData.left,\n          top: cropBoxData.top,\n          width: cropBoxData.width,\n          height: cropBoxData.height\n        };\n      }\n      return data || {};\n    },\n    /**\n     * Set the crop box position and size with new data.\n     * @param {Object} data - The new crop box data.\n     * @returns {Cropper} this\n     */\n    setCropBoxData: function setCropBoxData(data) {\n      var cropBoxData = this.cropBoxData;\n      var aspectRatio = this.options.aspectRatio;\n      var widthChanged;\n      var heightChanged;\n      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          cropBoxData.left = data.left;\n        }\n        if (isNumber(data.top)) {\n          cropBoxData.top = data.top;\n        }\n        if (isNumber(data.width) && data.width !== cropBoxData.width) {\n          widthChanged = true;\n          cropBoxData.width = data.width;\n        }\n        if (isNumber(data.height) && data.height !== cropBoxData.height) {\n          heightChanged = true;\n          cropBoxData.height = data.height;\n        }\n        if (aspectRatio) {\n          if (widthChanged) {\n            cropBoxData.height = cropBoxData.width / aspectRatio;\n          } else if (heightChanged) {\n            cropBoxData.width = cropBoxData.height * aspectRatio;\n          }\n        }\n        this.renderCropBox();\n      }\n      return this;\n    },\n    /**\n     * Get a canvas drawn the cropped image.\n     * @param {Object} [options={}] - The config options.\n     * @returns {HTMLCanvasElement} - The result canvas.\n     */\n    getCroppedCanvas: function getCroppedCanvas() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!this.ready || !window.HTMLCanvasElement) {\n        return null;\n      }\n      var canvasData = this.canvasData;\n      var source = getSourceCanvas(this.image, this.imageData, canvasData, options);\n\n      // Returns the source canvas if it is not cropped.\n      if (!this.cropped) {\n        return source;\n      }\n      var _this$getData = this.getData(),\n        initialX = _this$getData.x,\n        initialY = _this$getData.y,\n        initialWidth = _this$getData.width,\n        initialHeight = _this$getData.height;\n      var ratio = source.width / Math.floor(canvasData.naturalWidth);\n      if (ratio !== 1) {\n        initialX *= ratio;\n        initialY *= ratio;\n        initialWidth *= ratio;\n        initialHeight *= ratio;\n      }\n      var aspectRatio = initialWidth / initialHeight;\n      var maxSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.maxWidth || Infinity,\n        height: options.maxHeight || Infinity\n      });\n      var minSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: options.minWidth || 0,\n        height: options.minHeight || 0\n      }, 'cover');\n      var _getAdjustedSizes = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: options.width || (ratio !== 1 ? source.width : initialWidth),\n          height: options.height || (ratio !== 1 ? source.height : initialHeight)\n        }),\n        width = _getAdjustedSizes.width,\n        height = _getAdjustedSizes.height;\n      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      canvas.width = normalizeDecimalNumber(width);\n      canvas.height = normalizeDecimalNumber(height);\n      context.fillStyle = options.fillColor || 'transparent';\n      context.fillRect(0, 0, width, height);\n      var _options$imageSmoothi = options.imageSmoothingEnabled,\n        imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,\n        imageSmoothingQuality = options.imageSmoothingQuality;\n      context.imageSmoothingEnabled = imageSmoothingEnabled;\n      if (imageSmoothingQuality) {\n        context.imageSmoothingQuality = imageSmoothingQuality;\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      var sourceWidth = source.width;\n      var sourceHeight = source.height;\n\n      // Source canvas parameters\n      var srcX = initialX;\n      var srcY = initialY;\n      var srcWidth;\n      var srcHeight;\n\n      // Destination canvas parameters\n      var dstX;\n      var dstY;\n      var dstWidth;\n      var dstHeight;\n      if (srcX <= -initialWidth || srcX > sourceWidth) {\n        srcX = 0;\n        srcWidth = 0;\n        dstX = 0;\n        dstWidth = 0;\n      } else if (srcX <= 0) {\n        dstX = -srcX;\n        srcX = 0;\n        srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n        dstWidth = srcWidth;\n      } else if (srcX <= sourceWidth) {\n        dstX = 0;\n        srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n        dstWidth = srcWidth;\n      }\n      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n        srcY = 0;\n        srcHeight = 0;\n        dstY = 0;\n        dstHeight = 0;\n      } else if (srcY <= 0) {\n        dstY = -srcY;\n        srcY = 0;\n        srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n        dstHeight = srcHeight;\n      } else if (srcY <= sourceHeight) {\n        dstY = 0;\n        srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n        dstHeight = srcHeight;\n      }\n      var params = [srcX, srcY, srcWidth, srcHeight];\n\n      // Avoid \"IndexSizeError\"\n      if (dstWidth > 0 && dstHeight > 0) {\n        var scale = width / initialWidth;\n        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n      }\n\n      // All the numerical parameters should be integer for `drawImage`\n      // https://github.com/fengyuanchen/cropper/issues/476\n      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {\n        return Math.floor(normalizeDecimalNumber(param));\n      }))));\n      return canvas;\n    },\n    /**\n     * Change the aspect ratio of the crop box.\n     * @param {number} aspectRatio - The new aspect ratio.\n     * @returns {Cropper} this\n     */\n    setAspectRatio: function setAspectRatio(aspectRatio) {\n      var options = this.options;\n      if (!this.disabled && !isUndefined(aspectRatio)) {\n        // 0 -> NaN\n        options.aspectRatio = Math.max(0, aspectRatio) || NaN;\n        if (this.ready) {\n          this.initCropBox();\n          if (this.cropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n      return this;\n    },\n    /**\n     * Change the drag mode.\n     * @param {string} mode - The new drag mode.\n     * @returns {Cropper} this\n     */\n    setDragMode: function setDragMode(mode) {\n      var options = this.options,\n        dragBox = this.dragBox,\n        face = this.face;\n      if (this.ready && !this.disabled) {\n        var croppable = mode === DRAG_MODE_CROP;\n        var movable = options.movable && mode === DRAG_MODE_MOVE;\n        mode = croppable || movable ? mode : DRAG_MODE_NONE;\n        options.dragMode = mode;\n        setData(dragBox, DATA_ACTION, mode);\n        toggleClass(dragBox, CLASS_CROP, croppable);\n        toggleClass(dragBox, CLASS_MOVE, movable);\n        if (!options.cropBoxMovable) {\n          // Sync drag mode to crop box when it is not movable\n          setData(face, DATA_ACTION, mode);\n          toggleClass(face, CLASS_CROP, croppable);\n          toggleClass(face, CLASS_MOVE, movable);\n        }\n      }\n      return this;\n    }\n  };\n  var AnotherCropper = WINDOW.Cropper;\n  var Cropper = /*#__PURE__*/function () {\n    /**\n     * Create a new Cropper.\n     * @param {Element} element - The target element for cropping.\n     * @param {Object} [options={}] - The configuration options.\n     */\n    function Cropper(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, Cropper);\n      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {\n        throw new Error('The first argument is required and must be an <img> or <canvas> element.');\n      }\n      this.element = element;\n      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n      this.cropped = false;\n      this.disabled = false;\n      this.pointers = {};\n      this.ready = false;\n      this.reloading = false;\n      this.replaced = false;\n      this.sized = false;\n      this.sizing = false;\n      this.init();\n    }\n    _createClass(Cropper, [{\n      key: \"init\",\n      value: function init() {\n        var element = this.element;\n        var tagName = element.tagName.toLowerCase();\n        var url;\n        if (element[NAMESPACE]) {\n          return;\n        }\n        element[NAMESPACE] = this;\n        if (tagName === 'img') {\n          this.isImg = true;\n\n          // e.g.: \"img/picture.jpg\"\n          url = element.getAttribute('src') || '';\n          this.originalUrl = url;\n\n          // Stop when it's a blank image\n          if (!url) {\n            return;\n          }\n\n          // e.g.: \"https://example.com/img/picture.jpg\"\n          url = element.src;\n        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {\n          url = element.toDataURL();\n        }\n        this.load(url);\n      }\n    }, {\n      key: \"load\",\n      value: function load(url) {\n        var _this = this;\n        if (!url) {\n          return;\n        }\n        this.url = url;\n        this.imageData = {};\n        var element = this.element,\n          options = this.options;\n        if (!options.rotatable && !options.scalable) {\n          options.checkOrientation = false;\n        }\n\n        // Only IE10+ supports Typed Arrays\n        if (!options.checkOrientation || !window.ArrayBuffer) {\n          this.clone();\n          return;\n        }\n\n        // Detect the mime type of the image directly if it is a Data URL\n        if (REGEXP_DATA_URL.test(url)) {\n          // Read ArrayBuffer from Data URL of JPEG images directly for better performance\n          if (REGEXP_DATA_URL_JPEG.test(url)) {\n            this.read(dataURLToArrayBuffer(url));\n          } else {\n            // Only a JPEG image may contains Exif Orientation information,\n            // the rest types of Data URLs are not necessary to check orientation at all.\n            this.clone();\n          }\n          return;\n        }\n\n        // 1. Detect the mime type of the image by a XMLHttpRequest.\n        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.\n        var xhr = new XMLHttpRequest();\n        var clone = this.clone.bind(this);\n        this.reloading = true;\n        this.xhr = xhr;\n\n        // 1. Cross origin requests are only supported for protocol schemes:\n        // http, https, data, chrome, chrome-extension.\n        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy\n        // in some browsers as IE11 and Safari.\n        xhr.onabort = clone;\n        xhr.onerror = clone;\n        xhr.ontimeout = clone;\n        xhr.onprogress = function () {\n          // Abort the request directly if it not a JPEG image for better performance\n          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {\n            xhr.abort();\n          }\n        };\n        xhr.onload = function () {\n          _this.read(xhr.response);\n        };\n        xhr.onloadend = function () {\n          _this.reloading = false;\n          _this.xhr = null;\n        };\n\n        // Bust cache when there is a \"crossOrigin\" property to avoid browser cache error\n        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {\n          url = addTimestamp(url);\n        }\n\n        // The third parameter is required for avoiding side-effect (#682)\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.withCredentials = element.crossOrigin === 'use-credentials';\n        xhr.send();\n      }\n    }, {\n      key: \"read\",\n      value: function read(arrayBuffer) {\n        var options = this.options,\n          imageData = this.imageData;\n\n        // Reset the orientation value to its default value 1\n        // as some iOS browsers will render image with its orientation\n        var orientation = resetAndGetOrientation(arrayBuffer);\n        var rotate = 0;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (orientation > 1) {\n          // Generate a new URL which has the default orientation value\n          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);\n          var _parseOrientation = parseOrientation(orientation);\n          rotate = _parseOrientation.rotate;\n          scaleX = _parseOrientation.scaleX;\n          scaleY = _parseOrientation.scaleY;\n        }\n        if (options.rotatable) {\n          imageData.rotate = rotate;\n        }\n        if (options.scalable) {\n          imageData.scaleX = scaleX;\n          imageData.scaleY = scaleY;\n        }\n        this.clone();\n      }\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var element = this.element,\n          url = this.url;\n        var crossOrigin = element.crossOrigin;\n        var crossOriginUrl = url;\n        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {\n          if (!crossOrigin) {\n            crossOrigin = 'anonymous';\n          }\n\n          // Bust cache when there is not a \"crossOrigin\" property (#519)\n          crossOriginUrl = addTimestamp(url);\n        }\n        this.crossOrigin = crossOrigin;\n        this.crossOriginUrl = crossOriginUrl;\n        var image = document.createElement('img');\n        if (crossOrigin) {\n          image.crossOrigin = crossOrigin;\n        }\n        image.src = crossOriginUrl || url;\n        image.alt = element.alt || 'The image to crop';\n        this.image = image;\n        image.onload = this.start.bind(this);\n        image.onerror = this.stop.bind(this);\n        addClass(image, CLASS_HIDE);\n        element.parentNode.insertBefore(image, element.nextSibling);\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        this.sizing = true;\n\n        // Match all browsers that use WebKit as the layout engine in iOS devices,\n        // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);\n        var done = function done(naturalWidth, naturalHeight) {\n          assign(_this2.imageData, {\n            naturalWidth: naturalWidth,\n            naturalHeight: naturalHeight,\n            aspectRatio: naturalWidth / naturalHeight\n          });\n          _this2.initialImageData = assign({}, _this2.imageData);\n          _this2.sizing = false;\n          _this2.sized = true;\n          _this2.build();\n        };\n\n        // Most modern browsers (excepts iOS WebKit)\n        if (image.naturalWidth && !isIOSWebKit) {\n          done(image.naturalWidth, image.naturalHeight);\n          return;\n        }\n        var sizingImage = document.createElement('img');\n        var body = document.body || document.documentElement;\n        this.sizingImage = sizingImage;\n        sizingImage.onload = function () {\n          done(sizingImage.width, sizingImage.height);\n          if (!isIOSWebKit) {\n            body.removeChild(sizingImage);\n          }\n        };\n        sizingImage.src = image.src;\n\n        // iOS WebKit will convert the image automatically\n        // with its orientation once append it into DOM (#279)\n        if (!isIOSWebKit) {\n          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n          body.appendChild(sizingImage);\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var image = this.image;\n        image.onload = null;\n        image.onerror = null;\n        image.parentNode.removeChild(image);\n        this.image = null;\n      }\n    }, {\n      key: \"build\",\n      value: function build() {\n        if (!this.sized || this.ready) {\n          return;\n        }\n        var element = this.element,\n          options = this.options,\n          image = this.image;\n\n        // Create cropper elements\n        var container = element.parentNode;\n        var template = document.createElement('div');\n        template.innerHTML = TEMPLATE;\n        var cropper = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n        var canvas = cropper.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n        var dragBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-drag-box\"));\n        var cropBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-crop-box\"));\n        var face = cropBox.querySelector(\".\".concat(NAMESPACE, \"-face\"));\n        this.container = container;\n        this.cropper = cropper;\n        this.canvas = canvas;\n        this.dragBox = dragBox;\n        this.cropBox = cropBox;\n        this.viewBox = cropper.querySelector(\".\".concat(NAMESPACE, \"-view-box\"));\n        this.face = face;\n        canvas.appendChild(image);\n\n        // Hide the original image\n        addClass(element, CLASS_HIDDEN);\n\n        // Inserts the cropper after to the current image\n        container.insertBefore(cropper, element.nextSibling);\n\n        // Show the hidden image\n        removeClass(image, CLASS_HIDE);\n        this.initPreview();\n        this.bind();\n        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;\n        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;\n        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;\n        addClass(cropBox, CLASS_HIDDEN);\n        if (!options.guides) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-dashed\")), CLASS_HIDDEN);\n        }\n        if (!options.center) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-center\")), CLASS_HIDDEN);\n        }\n        if (options.background) {\n          addClass(cropper, \"\".concat(NAMESPACE, \"-bg\"));\n        }\n        if (!options.highlight) {\n          addClass(face, CLASS_INVISIBLE);\n        }\n        if (options.cropBoxMovable) {\n          addClass(face, CLASS_MOVE);\n          setData(face, DATA_ACTION, ACTION_ALL);\n        }\n        if (!options.cropBoxResizable) {\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-line\")), CLASS_HIDDEN);\n          addClass(cropBox.getElementsByClassName(\"\".concat(NAMESPACE, \"-point\")), CLASS_HIDDEN);\n        }\n        this.render();\n        this.ready = true;\n        this.setDragMode(options.dragMode);\n        if (options.autoCrop) {\n          this.crop();\n        }\n        this.setData(options.data);\n        if (isFunction(options.ready)) {\n          addListener(element, EVENT_READY, options.ready, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_READY);\n      }\n    }, {\n      key: \"unbuild\",\n      value: function unbuild() {\n        if (!this.ready) {\n          return;\n        }\n        this.ready = false;\n        this.unbind();\n        this.resetPreview();\n        var parentNode = this.cropper.parentNode;\n        if (parentNode) {\n          parentNode.removeChild(this.cropper);\n        }\n        removeClass(this.element, CLASS_HIDDEN);\n      }\n    }, {\n      key: \"uncreate\",\n      value: function uncreate() {\n        if (this.ready) {\n          this.unbuild();\n          this.ready = false;\n          this.cropped = false;\n        } else if (this.sizing) {\n          this.sizingImage.onload = null;\n          this.sizing = false;\n          this.sized = false;\n        } else if (this.reloading) {\n          this.xhr.onabort = null;\n          this.xhr.abort();\n        } else if (this.image) {\n          this.stop();\n        }\n      }\n\n      /**\n       * Get the no conflict cropper class.\n       * @returns {Cropper} The cropper class.\n       */\n    }], [{\n      key: \"noConflict\",\n      value: function noConflict() {\n        window.Cropper = AnotherCropper;\n        return Cropper;\n      }\n\n      /**\n       * Change the default options.\n       * @param {Object} options - The new default options.\n       */\n    }, {\n      key: \"setDefaults\",\n      value: function setDefaults(options) {\n        assign(DEFAULTS, isPlainObject(options) && options);\n      }\n    }]);\n    return Cropper;\n  }();\n  assign(Cropper.prototype, render, preview, events, handlers, change, methods);\n  return Cropper;\n});\n\n//# sourceURL=webpack://inheart/./node_modules/cropperjs/dist/cropper.js?");

/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiDrag: function() { return /* binding */ MultiDragPlugin; },\n/* harmony export */   Sortable: function() { return /* binding */ Sortable; },\n/* harmony export */   Swap: function() { return /* binding */ SwapPlugin; }\n/* harmony export */ });\n/**!\n * Sortable 1.15.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar version = \"1.15.0\";\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\nvar captureMode = {\n  capture: false,\n  passive: false\n};\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\nfunction matches( /**HTMLElement*/\nel, /**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n  return false;\n}\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\nfunction closest( /**HTMLElement*/\nel, /**String*/\nselector, /**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n  return null;\n}\nvar R_SPACE = /\\s+/g;\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\nfunction css(el, prop, val) {\n  var style = el && el.style;\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n    return list;\n  }\n  return [];\n}\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n      } while (container = container.parentNode);\n    }\n  }\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n    elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n      visible = void 0;\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n    i = 0,\n    children = el.children;\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n    i++;\n  }\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\nfunction index(el, selector) {\n  var index = 0;\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while (elem = elem.parentNode);\n  return getWindowScrollingElement();\n}\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n  return dst;\n}\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\nvar _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n        _this = this;\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\nvar expando = 'Sortable' + new Date().getTime();\nfunction AnimationStateManager() {\n  var animationStates = [],\n    animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n      var animating = false,\n        animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n          target = state.target,\n          fromRect = target.fromRect,\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n        target.toRect = toRect;\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&\n          // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n          if (!time) {\n            time = _this.options.animation;\n          }\n          _this.animate(target, animatingRect, toRect, time);\n        }\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\nfunction repaint(target) {\n  return target.offsetWidth;\n}\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n    this.eventCanceled = false;\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n    rootEl = _ref.rootEl,\n    name = _ref.name,\n    targetEl = _ref.targetEl,\n    cloneEl = _ref.cloneEl,\n    toEl = _ref.toEl,\n    fromEl = _ref.fromEl,\n    oldIndex = _ref.oldIndex,\n    newIndex = _ref.newIndex,\n    oldDraggableIndex = _ref.oldDraggableIndex,\n    newDraggableIndex = _ref.newDraggableIndex,\n    originalEvent = _ref.originalEvent,\n    putSortable = _ref.putSortable,\n    extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n    options = sortable.options,\n    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\nvar _excluded = [\"evt\"];\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    originalEvent = _ref.evt,\n    data = _objectWithoutProperties(_ref, _excluded);\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\nvar dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [],\n  // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n  supportCssPointerEvents = function () {\n    if (!documentExists) return; // false when <= IE11\n\n    if (IE11OrLess) {\n      return false;\n    }\n    var el = document.createElement('x');\n    el.style.cssText = 'pointer-events:auto';\n    return el.style.pointerEvents === 'auto';\n  }(),\n  _detectDirection = function _detectDirection(el, options) {\n    var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n    if (elCSS.display === 'flex') {\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n    }\n    if (elCSS.display === 'grid') {\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n    }\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n    }\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n  },\n  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n  },\n  /**\r\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n   * @param  {Number} x      X position\r\n   * @param  {Number} y      Y position\r\n   * @return {HTMLElement}   Element of the first found nearest Sortable\r\n   */\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n    var ret;\n    sortables.some(function (sortable) {\n      var threshold = sortable[expando].options.emptyInsertThreshold;\n      if (!threshold || lastChild(sortable)) return;\n      var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n      if (insideHorizontally && insideVertically) {\n        return ret = sortable;\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function _prepareGroup(options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === 'clone') {\n          return value;\n        } else if (typeof value === 'function') {\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n        } else {\n          var otherGroup = (pull ? to : from).options.group.name;\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n        }\n      };\n    }\n    var group = {};\n    var originalGroup = options.group;\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\n      originalGroup = {\n        name: originalGroup\n      };\n    }\n    group.name = originalGroup.name;\n    group.checkPull = toFn(originalGroup.pull, true);\n    group.checkPut = toFn(originalGroup.put);\n    group.revertClone = originalGroup.revertClone;\n    options.group = group;\n  },\n  _hideGhostForTarget = function _hideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', 'none');\n    }\n  },\n  _unhideGhostForTarget = function _unhideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', '');\n    }\n  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\nif (documentExists && !ChromeForAndroid) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\r\n * @class  Sortable\r\n * @param  {HTMLElement}  el\r\n * @param  {Object}       [options]\r\n */\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n  _prepareGroup(options); // Bind all private methods\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\nSortable.prototype = /** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart( /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n    var _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n      target = (touch || evt).target,\n      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n      filter = options.filter;\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n    if (dragEl) {\n      return;\n    }\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n    target = closest(target, options.draggable, el, false);\n    if (target && target.animated) {\n      return;\n    }\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart( /** Event */\n  evt, /** Touch */\n  touch, /** HTMLElement */\n  target) {\n    var _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n        _this._disableDelayedDragEvents();\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart( /** Event */\n  evt, /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n      _hideGhostForTarget();\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n          target = parent; // store last element\n        }\n        /* jshint boss:true */ while (parent = parent.parentNode);\n      }\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove( /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart( /**Event*/\n  evt, /**boolean*/\n  fallback) {\n    var _this = this;\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n    pluginEvent('setupClone', this);\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.removeAttribute(\"id\");\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n      this._hideClone();\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver( /**Event*/\n  evt) {\n    var el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n    if (_silent) return;\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n    ignoreNextClick = false;\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n        this._hideClone();\n        dragOverEvent('revert');\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n        return completed(true);\n      }\n      var elLastChild = lastChild(el, options.draggable);\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // if there is a last element, it is the target\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n        if (target) {\n          targetRect = getRect(target);\n        }\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          if (elLastChild && elLastChild.nextSibling) {\n            // the last draggable element is not the last node\n            el.insertBefore(dragEl, elLastChild.nextSibling);\n          } else {\n            el.appendChild(dragEl);\n          }\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n        target = firstChild;\n        targetRect = getRect(target);\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n          side1 = vertical ? 'top' : 'left',\n          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n          after = false;\n        after = direction === 1;\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n          changed();\n          return completed(true);\n        }\n      }\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop( /**Event*/\n  evt) {\n    var el = this.el,\n      options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n    css(dragEl, 'transform', '');\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n        _disableDraggable(dragEl);\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent( /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n        break;\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n  /**\r\n   * Serializes the item into an array of string.\r\n   * @returns {String[]}\r\n   */\n  toArray: function toArray() {\n    var order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n    return order;\n  },\n  /**\r\n   * Sorts the elements according to the array.\r\n   * @param  {String[]}  order  order of the items\r\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n      rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n  /**\r\n   * Save the current sorting\r\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n  /**\r\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n   * @param   {HTMLElement}  el\r\n   * @param   {String}       [selector]  default: `options.draggable`\r\n   * @returns {HTMLElement|null}\r\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n  /**\r\n   * Set/get option\r\n   * @param   {string} name\r\n   * @param   {*}      [value]\r\n   * @returns {*}\r\n   */\n  option: function option(name, value) {\n    var options = this.options;\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n  /**\r\n   * Destroy\r\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n    this._onDrop();\n    this._disableDelayedDragEvents();\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n      return;\n    }\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\nfunction _globalDragOver( /**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n  evt.cancelable && evt.preventDefault();\n}\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n  return retVal;\n}\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\nfunction _unsilent() {\n  _silent = false;\n}\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var spacer = 10;\n  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\n}\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n  invert = invert || invertSwap;\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n  return 0;\n}\n/**\r\n * Gets the direction dragEl must be swapped relative to target in order to make it\r\n * seem that dragEl has been \"inserted\" into that element's position\r\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n * @return {Number}                   Direction dragEl must be swapped\r\n */\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\r\n * Generate id\r\n * @param   {HTMLElement} el\r\n * @returns {String}\r\n * @private\r\n */\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n  return sum.toString(36);\n}\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\r\n * Get the Sortable instance of an element\r\n * @param  {HTMLElement} element The element\r\n * @return {Sortable|undefined}         The instance of Sortable\r\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\r\n * Mount a plugin to Sortable\r\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n */\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\r\n * Create sortable instance\r\n * @param {HTMLElement}  el\r\n * @param {Object}      [options]\r\n */\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\nSortable.version = version;\nvar autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt$1,\n  pointerElemChangedInterval;\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n    scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n  var layersOut = 0;\n  var currentParent = scrollEl;\n  do {\n    var el = currentParent,\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX = void 0,\n      canScrollY = void 0,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n    putSortable = _ref.putSortable,\n    dragEl = _ref.dragEl,\n    activeSortable = _ref.activeSortable,\n    dispatchSortableEvent = _ref.dispatchSortableEvent,\n    hideGhostForTarget = _ref.hideGhostForTarget,\n    unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\nfunction Revert() {}\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n      putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\nfunction Remove() {}\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n      putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\nvar lastSwapEl;\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n        target = _ref2.target,\n        onMove = _ref2.onMove,\n        activeSortable = _ref2.activeSortable,\n        changed = _ref2.changed,\n        cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n        putSortable = _ref3.putSortable,\n        dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\nvar multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect,\n  // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false,\n  // Initial multi-drag fold when drag started\n  folding = false,\n  // Folding any other time\n  dragStarted = false,\n  dragEl$1,\n  clonesFromRect,\n  clonesHidden;\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n    if (!sortable.options.avoidImplicitDeselect) {\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n    }\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      avoidImplicitDeselect: false,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n        cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n      sortable._hideClone();\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n        rootEl = _ref3.rootEl,\n        dispatchSortableEvent = _ref3.dispatchSortableEvent,\n        cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n        rootEl = _ref4.rootEl,\n        cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n      var sortable = _ref5.sortable,\n        cloneNowHidden = _ref5.cloneNowHidden,\n        cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n        completed = _ref8.completed,\n        cancel = _ref8.cancel;\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n        rootEl = _ref9.rootEl,\n        sortable = _ref9.sortable,\n        dragRect = _ref9.dragRect;\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n        isOwner = _ref10.isOwner,\n        insertion = _ref10.insertion,\n        activeSortable = _ref10.activeSortable,\n        parentEl = _ref10.parentEl,\n        putSortable = _ref10.putSortable;\n      var options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n        isOwner = _ref11.isOwner,\n        activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n        rootEl = _ref12.rootEl,\n        parentEl = _ref12.parentEl,\n        sortable = _ref12.sortable,\n        dispatchSortableEvent = _ref12.dispatchSortableEvent,\n        oldIndex = _ref12.oldIndex,\n        putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n        children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n              currentIndex = index(dragEl$1);\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvent: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          });\n        }\n      } // Multi-drag drop\n\n      if (dragStarted && this.isMultiDrag) {\n        folding = false; // Do not \"unfold\" after around dragEl if reverted\n\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvent: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n      var oldIndicies = [],\n        newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      }\n    }\n  });\n}\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sortable);\n\n\n//# sourceURL=webpack://inheart/./node_modules/sortablejs/modular/sortable.esm.js?");

/***/ }),

/***/ "./src/js/common/global.js":
/*!*********************************!*\
  !*** ./src/js/common/global.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BYTES_IN_MB: function() { return /* binding */ BYTES_IN_MB; },\n/* harmony export */   TRANSITION_DURATION: function() { return /* binding */ TRANSITION_DURATION; },\n/* harmony export */   WINDOW_LG: function() { return /* binding */ WINDOW_LG; },\n/* harmony export */   WINDOW_XL: function() { return /* binding */ WINDOW_XL; },\n/* harmony export */   addLoader: function() { return /* binding */ addLoader; },\n/* harmony export */   ajaxUrl: function() { return /* binding */ ajaxUrl; },\n/* harmony export */   checkAjaxWorkingStatus: function() { return /* binding */ checkAjaxWorkingStatus; },\n/* harmony export */   customDebounce: function() { return /* binding */ customDebounce; },\n/* harmony export */   disableInput: function() { return /* binding */ disableInput; },\n/* harmony export */   enableInput: function() { return /* binding */ enableInput; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   formatNumber: function() { return /* binding */ formatNumber; },\n/* harmony export */   getTargetElement: function() { return /* binding */ getTargetElement; },\n/* harmony export */   hideAreYouSurePopup: function() { return /* binding */ hideAreYouSurePopup; },\n/* harmony export */   hideElement: function() { return /* binding */ hideElement; },\n/* harmony export */   hideFormErrors: function() { return /* binding */ hideFormErrors; },\n/* harmony export */   hideFormFieldError: function() { return /* binding */ hideFormFieldError; },\n/* harmony export */   ihAjaxRequest: function() { return /* binding */ ihAjaxRequest; },\n/* harmony export */   removeLoader: function() { return /* binding */ removeLoader; },\n/* harmony export */   setAjaxWorkingStatus: function() { return /* binding */ setAjaxWorkingStatus; },\n/* harmony export */   setTargetElement: function() { return /* binding */ setTargetElement; },\n/* harmony export */   showAreYouSurePopup: function() { return /* binding */ showAreYouSurePopup; },\n/* harmony export */   showElement: function() { return /* binding */ showElement; },\n/* harmony export */   showFormErrors: function() { return /* binding */ showFormErrors; },\n/* harmony export */   showImagePopup: function() { return /* binding */ showImagePopup; },\n/* harmony export */   showNotification: function() { return /* binding */ showNotification; },\n/* harmony export */   submitAjaxForm: function() { return /* binding */ submitAjaxForm; },\n/* harmony export */   submitAuthForm: function() { return /* binding */ submitAuthForm; },\n/* harmony export */   switcherLogic: function() { return /* binding */ switcherLogic; }\n/* harmony export */ });\n/* harmony import */ var body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! body-scroll-lock */ \"./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar ajaxUrl = window.wpData.ajaxUrl,\n  TRANSITION_DURATION = 350,\n  BYTES_IN_MB = 1048576,\n  WINDOW_LG = 992,\n  WINDOW_XL = 1320;\nvar isAjaxWorking = false,\n  targetElement;\n\n// Check if AJAX is working now.\nvar checkAjaxWorkingStatus = function checkAjaxWorkingStatus() {\n  return isAjaxWorking;\n};\n\n/**\r\n * Set AJAX status.\r\n *\r\n * @param {Boolean} status\r\n */\nvar setAjaxWorkingStatus = function setAjaxWorkingStatus(status) {\n  return isAjaxWorking = status;\n};\n\n/**\r\n * Custom AJAX request.\r\n *\r\n * @param\t{Object}\tformData\tData for fetch body.\r\n * @param \t{Object}\tsettings\tFetch settings object.\r\n * @returns\t{Array}\t\t\t\t\tResponse data array.\r\n */\nvar ihAjaxRequest = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(formData) {\n    var settings,\n      defaultSettings,\n      response,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          settings = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n          defaultSettings = _objectSpread(_objectSpread({\n            method: 'post'\n          }, settings), {}, {\n            body: formData\n          });\n          _context.next = 4;\n          return fetch(ajaxUrl, defaultSettings);\n        case 4:\n          response = _context.sent;\n          _context.next = 7;\n          return response.json();\n        case 7:\n          return _context.abrupt(\"return\", _context.sent);\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function ihAjaxRequest(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\r\n * Highlight form labels with errors.\r\n *\r\n * @param {HTMLObjectElement}\tform\r\n * @param {Object}\t\t\t\terrors\tContains items with props: field, error.\r\n */\nvar showFormErrors = function showFormErrors(form, errors) {\n  errors.forEach(function (error) {\n    var fieldErrorLabels = form.querySelectorAll(\"label[data-for=\\\"\".concat(error.field, \"\\\"]\"));\n    if (!fieldErrorLabels.length) {\n      fieldErrorLabels = form.querySelectorAll(\"label[for=\\\"\".concat(error.field, \"\\\"]\"));\n      if (!fieldErrorLabels.length) return;\n    }\n    fieldErrorLabels.forEach(function (label) {\n      label.classList.add('error');\n      var fieldError = label.querySelector('.field-error');\n      if (!fieldError) return;\n      fieldError.classList.remove('hidden');\n      fieldError.innerHTML = error.error;\n    });\n  });\n};\n\n/**\r\n * Hide all fields errors inside specific form.\r\n *\r\n * @param {HTMLObjectElement}\tform\r\n */\nvar hideFormErrors = function hideFormErrors(form) {\n  var labelsWithErrors = form.querySelectorAll('label.error');\n  if (!labelsWithErrors.length) return;\n  labelsWithErrors.forEach(function (label) {\n    return hideFormFieldError(label);\n  });\n};\n\n/**\r\n * Hide an error for specific field.\r\n *\r\n * @param {HTMLObjectElement}\tlabel\tAnimated label with error.\r\n */\nvar hideFormFieldError = function hideFormFieldError(label) {\n  label.classList.remove('error');\n  var field = label.querySelector('.field-error');\n  if (!field) return;\n  field.innerHTML = '';\n  field.classList.add('hidden');\n};\n\n/**\r\n * Set variable for disableScrollLock.\r\n *\r\n * @param\t{String}\telementId\tSpecific element ID.\r\n * @returns\t{Boolean}\t\t\t\tTrue if element is set, false if not.\r\n */\nvar setTargetElement = function setTargetElement(elementId) {\n  if (!elementId) {\n    targetElement = null;\n    return false;\n  }\n  var el = document.querySelector(elementId);\n  if (el) {\n    targetElement = el;\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Get element for disableScrollLock.\r\n *\r\n * @returns targetElement value.\r\n */\nvar getTargetElement = function getTargetElement() {\n  return targetElement;\n};\n\n/**\r\n * Submit form via AJAX.\r\n *\r\n * @param {String}\tformSelector\tSpecific form CSS-selector.\r\n * @param {String}\taction\t\t\tAJAX action name.\r\n */\nvar submitAjaxForm = function submitAjaxForm(formSelector, action) {\n  var form = document.querySelector(formSelector);\n  if (!form) return;\n  return form.addEventListener('submit', function (e) {\n    e.preventDefault();\n    if (checkAjaxWorkingStatus()) return;\n    setAjaxWorkingStatus(true);\n    var note = form.querySelector('.note'),\n      formData = new FormData(form);\n    hideFormErrors(form);\n    if (note) note.innerHTML = '';\n    form.classList.add('disabled');\n    formData.append('action', action);\n    ihAjaxRequest(formData).then(function (res) {\n      form.classList.remove('disabled');\n      if (res) {\n        switch (res.success) {\n          case true:\n            if (note) note.innerHTML = res.data.msg;\n            form.reset();\n            break;\n          case false:\n            console.error(res.data.msg);\n            if (res.data.errors) {\n              showFormErrors(form, res.data.errors);\n            } else {\n              if (note) note.innerHTML = res.data.msg;\n            }\n            break;\n        }\n      }\n      setAjaxWorkingStatus(false);\n    });\n  });\n};\n\n/**\r\n * Submit Authorization forms via AJAX.\r\n *\r\n * @param {String}\tformSelector\tSpecific form CSS-selector.\r\n * @param {String}\taction\t\t\tAJAX action name.\r\n */\nvar submitAuthForm = function submitAuthForm(formSelector, action) {\n  var form = document.querySelector(formSelector);\n  if (!form) return;\n  form.addEventListener('submit', function (e) {\n    e.preventDefault();\n    if (checkAjaxWorkingStatus()) return;\n    setAjaxWorkingStatus(true);\n    var note = form.querySelector('.note'),\n      formData = new FormData(form);\n    hideFormErrors(form);\n    if (note) note.innerHTML = '';\n    form.classList.add('disabled');\n    formData.append('action', action);\n    ihAjaxRequest(formData).then(function (res) {\n      form.classList.remove('disabled');\n      if (res) {\n        switch (res.success) {\n          case true:\n            if (res.data.redirect) setTimeout(function () {\n              return window.location.href = res.data.redirect;\n            }, 1000);\n            if (note) {\n              note.classList.add('note-success');\n              note.innerHTML = res.data.msg;\n            }\n            break;\n          case false:\n            if (note) {\n              note.classList.add('note-error');\n              note.innerHTML = res.data.msg;\n            }\n            if (res.data.errors) showFormErrors(form, res.data.errors);\n            break;\n        }\n      }\n      setAjaxWorkingStatus(false);\n    });\n  });\n};\n\n/**\r\n * Append popup.\r\n *\r\n * @param {HTMLObjectElement}\tcontainer\t\tWhere to add popup.\r\n * @param {function}\t\t\tcancelCallback\tFires on popup cancel button click.\r\n * @param {function}\t\t\tapplyCallback\tFires on popup apply button click.\r\n */\nvar showAreYouSurePopup = function showAreYouSurePopup(container, cancelCallback, applyCallback) {\n  var question = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Дійсно видалити фото?';\n  if (document.querySelector('.popup-sure')) return;\n  var popup = \"<div class=\\\"popup-sure\\\">\\n\\t\\t<div class=\\\"popup-sure-text\\\">\".concat(question, \"</div>\\n\\t\\t<div class=\\\"popup-sure-buttons flex flex-wrap\\\">\\n\\t\\t\\t<button class=\\\"popup-sure-cancel\\\" type=\\\"button\\\">\\u0417\\u0430\\u043B\\u0438\\u0448\\u0438\\u0442\\u0438</button>\\n\\t\\t\\t<button class=\\\"popup-sure-apply\\\" type=\\\"button\\\">\\u0412\\u0438\\u0434\\u0430\\u043B\\u0438\\u0442\\u0438</button>\\n\\t\\t</div>\\n\\t</div>\");\n  container.insertAdjacentHTML('beforeend', popup);\n  document.querySelector('.popup-sure-cancel').addEventListener('click', cancelCallback);\n  document.querySelector('.popup-sure-apply').addEventListener('click', applyCallback);\n};\n\n/**\r\n * Remove popup.\r\n */\nvar hideAreYouSurePopup = function hideAreYouSurePopup() {\n  var popup = document.querySelector('.popup-sure');\n  if (popup) popup.remove();\n};\n\n/**\r\n * Show popup notification.\r\n *\r\n * @param {string} text Notification text.\r\n * @param {string} type\t'success' | 'error' | 'warning'\r\n */\nvar showNotification = function showNotification() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Please set the text';\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'success';\n  var notification = document.createElement('div');\n  notification.className = \"notification \".concat(type);\n  notification.innerText = text;\n  document.body.querySelector('.wrapper').appendChild(notification);\n  setTimeout(function () {\n    notification.classList.add('show');\n  }, 10);\n  setTimeout(function () {\n    notification.classList.remove('show');\n  }, 5000);\n  setTimeout(function () {\n    notification.remove();\n  }, 5000 + TRANSITION_DURATION);\n};\n\n/**\r\n * Show specific element by removing class '.hidden'.\r\n *\r\n * @param {HTMLObjectElement} el\r\n */\nvar showElement = function showElement(el) {\n  if (!el || !el.classList.contains('hidden')) return;\n  el.classList.remove('hidden');\n};\n\n/**\r\n * Hide specific element by adding class '.hidden'.\r\n *\r\n * @param {HTMLObjectElement} el\r\n */\nvar hideElement = function hideElement(el) {\n  if (!el || el.classList.contains('hidden')) return;\n  el.classList.add('hidden');\n};\n\n/**\r\n * Format number value.\r\n *\r\n * @param {string|number} number\tParameter value will be turned to float anyway.\r\n * @returns {string}\r\n */\nvar formatNumber = function formatNumber(number) {\n  return parseFloat(number).toLocaleString('us');\n};\n\n/**\r\n * Custom debounce function to improve performance.\r\n *\r\n * @param callback\r\n * @param delay\t\tValue in milliseconds.\r\n * @returns {(function(...[*]): void)|*}\r\n */\nvar customDebounce = function customDebounce(callback) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(function () {\n      return callback.apply(void 0, args);\n    }, delay);\n  };\n};\n\n/**\r\n * Switcher tabs logic.\r\n */\nvar switcherLogic = function switcherLogic() {\n  var switchers = document.querySelectorAll('.switcher');\n  if (!switchers.length) return;\n  switchers.forEach(function (switcher) {\n    switcher.addEventListener('click', function (e) {\n      var target = e.target;\n      if (target.className && target.classList.contains('tab') && !target.classList.contains('active')) {\n        switcher.querySelector('.tab.active').classList.remove('active');\n        target.classList.add('active');\n      }\n    });\n  });\n};\n\n/**\r\n * Append image popup.\r\n *\r\n * @param {HTMLObjectElement}\timage\r\n * @param {String}\t\t\t\timageWrapSelector\r\n */\nvar showImagePopup = function showImagePopup(image, imageWrapSelector) {\n  if (!image) return;\n  var popup = document.createElement('div'),\n    imageFull = document.createElement('img'),\n    src = image.closest(imageWrapSelector).dataset.full || '';\n  if (!src) return;\n  imageFull.src = src;\n  popup.classList.add('popup', 'popup-image');\n  popup.appendChild(imageFull);\n  document.body.appendChild(popup);\n  (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__.disableBodyScroll)(popup, {\n    reserveScrollBarGap: true\n  });\n\n  // Close popup.\n  popup.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.className && target.classList.contains('popup')) {\n      (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__.enableBodyScroll)(popup);\n      popup.remove();\n    }\n  });\n};\n\n/**\r\n * Disable input.\r\n *\r\n * @param {HTMLObjectElement} input\r\n */\nvar disableInput = function disableInput(input) {\n  input.classList.add('loading');\n  input.disabled = 'disabled';\n};\n\n/**\r\n * Enable input.\r\n *\r\n * @param {HTMLObjectElement} input\r\n */\nvar enableInput = function enableInput(input) {\n  input.classList.remove('loading');\n  input.removeAttribute('disabled');\n};\n\n/**\r\n * Append loader inside specific element.\r\n *\r\n * @param {HTMLObjectElement} elem\tElement to put loader in.\r\n */\nvar addLoader = function addLoader(elem) {\n  if (!elem) return;\n  var loader = '<div class=\"tmp-loader\"></div>';\n  elem.classList.add('loading');\n  elem.insertAdjacentHTML('beforeend', loader);\n};\n\n/**\r\n * Delete loader from specific element.\r\n *\r\n * @param {HTMLObjectElement} elem\tElement to delete loader from.\r\n */\nvar removeLoader = function removeLoader(elem) {\n  if (!elem) return;\n  var loader = elem.querySelector('.tmp-loader');\n  if (loader) {\n    elem.classList.remove('loading');\n    loader.remove();\n  }\n};\n\n/**\r\n * Get date in specific locale.\r\n *\r\n * @param date\r\n * @param locale\r\n * @returns {string}\r\n */\nvar formatDate = function formatDate(date) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'uk';\n  var options = {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    timezone: 'UTC'\n  };\n  return new Date(date).toLocaleString(locale, options);\n};\n\n//# sourceURL=webpack://inheart/./src/js/common/global.js?");

/***/ }),

/***/ "./src/js/new-memory/common.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/common.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNextStep: function() { return /* binding */ allowNextStep; },\n/* harmony export */   applyProgress: function() { return /* binding */ applyProgress; },\n/* harmony export */   defineGlobalStepsItems: function() { return /* binding */ defineGlobalStepsItems; },\n/* harmony export */   disallowNextStep: function() { return /* binding */ disallowNextStep; },\n/* harmony export */   isStepFilled: function() { return /* binding */ isStepFilled; },\n/* harmony export */   nextStep: function() { return /* binding */ nextStep; },\n/* harmony export */   prevStep: function() { return /* binding */ prevStep; }\n/* harmony export */ });\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\n/* harmony import */ var _step_0__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./step-0 */ \"./src/js/new-memory/step-0.js\");\n/* harmony import */ var _step_1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./step-1 */ \"./src/js/new-memory/step-1.js\");\n/* harmony import */ var _step_2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./step-2 */ \"./src/js/new-memory/step-2.js\");\n/* harmony import */ var _step_3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./step-3 */ \"./src/js/new-memory/step-3.js\");\n/* harmony import */ var _step_4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./step-4 */ \"./src/js/new-memory/step-4.js\");\n/* harmony import */ var _step_5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./step-5 */ \"./src/js/new-memory/step-5.js\");\n/* harmony import */ var _step_2_military__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./step-2-military */ \"./src/js/new-memory/step-2-military.js\");\n/* harmony import */ var _step_3_military__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./step-3-military */ \"./src/js/new-memory/step-3-military.js\");\n\n\n\n\n\n\n\n\n\nvar footer, progressBar, prevStepBtn, nextStepBtn, nextStepIdGlobal, prevStepIdGlobal;\n\n/**\r\n * Define all global variables required for all steps.\r\n *\r\n * @returns {boolean}\r\n */\nvar defineGlobalStepsItems = function defineGlobalStepsItems() {\n  footer = document.querySelector('.new-memory-footer');\n  progressBar = document.querySelector('.new-memory-progress-bar');\n  prevStepBtn = document.querySelector('.new-memory-prev-step');\n  nextStepBtn = document.querySelector('.new-memory-next-step');\n  return !(!footer || !progressBar || !prevStepBtn || !nextStepBtn);\n};\nvar isMilitaryTheme = function isMilitaryTheme() {\n  var stepData = localStorage.getItem('ih-step-0');\n  if (!stepData) return false;\n  stepData = JSON.parse(stepData);\n  return stepData.theme === 'military';\n};\n\n/**\r\n * Allow to go to the next step (enable Next button).\r\n *\r\n * @param {number} nextStepId\tID of the next step.\r\n */\nvar allowNextStep = function allowNextStep() {\n  var nextStepId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  nextStepBtn.removeAttribute('disabled');\n  nextStepBtn.dataset.next = \"\".concat(nextStepId);\n};\n\n/**\r\n * Disable next step button.\r\n */\nvar disallowNextStep = function disallowNextStep() {\n  nextStepBtn.setAttribute('disabled', 'true');\n  nextStepBtn.dataset.next = '';\n};\n\n/**\r\n * Fill one specific part of the progress bar with percentage.\r\n *\r\n * @param {number} partId\t\tWhich part of progress bar is active\r\n * @param {number} percentage\tPercents to fill\r\n */\nvar applyProgress = function applyProgress() {\n  var partId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var percentage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  var part = progressBar.querySelector(\"[data-part=\\\"\".concat(parseInt(partId), \"\\\"]\"));\n  if (!part) return;\n  part.querySelector('.new-memory-progress-inner').style.width = \"\".concat(percentage, \"%\");\n};\n\n/**\r\n * Save current step data and go to the next step.\r\n */\nvar nextStep = function nextStep() {\n  nextStepBtn.addEventListener('click', function () {\n    if (nextStepBtn.disabled) return;\n    if (!nextStepIdGlobal || (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n    var formData = new FormData(),\n      dataNext = parseInt(nextStepBtn.dataset.next);\n    formData.append('action', \"ih_ajax_save_data_step_\".concat(prevStepIdGlobal));\n    formData.append('stepData', localStorage.getItem(\"ih-step-\".concat(prevStepIdGlobal)) || '');\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n      if (res) {\n        switch (res.success) {\n          case true:\n            showNextStepSection();\n\n            // 6th step is the last, need to clean all the data and redirect.\n            if (dataNext === 6) {\n              theLastStep();\n              setTimeout(function () {\n                return window.location.href = res.data.redirect;\n              }, 3000);\n            }\n            break;\n          case false:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n            break;\n        }\n      }\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    });\n  });\n};\n\n/**\r\n * Hide current and show next step layout.\r\n *\r\n * @param {number} nextStepId\r\n */\nvar showNextStepSection = function showNextStepSection() {\n  document.querySelector('.new-memory-step.active').classList.remove('active');\n  document.querySelector(\"#new-memory-step-\".concat(nextStepIdGlobal)).classList.add('active');\n  prevStepBtn.classList.remove('hidden');\n  prevStepBtn.setAttribute('data-prev', prevStepIdGlobal);\n  isStepFilled(nextStepIdGlobal);\n};\n\n/**\r\n * Go to the previous step.\r\n */\nvar prevStep = function prevStep() {\n  prevStepBtn.addEventListener('click', function () {\n    if (prevStepBtn.classList.contains('hidden')) return;\n    var prevStepIdUpd = prevStepBtn.dataset.prev,\n      prevStepId = parseInt(prevStepIdUpd);\n    if (!prevStepId && prevStepId != '0') return;\n    if (!prevStepIdUpd.includes('-military')) prevStepIdUpd = prevStepId;\n    document.querySelector('.new-memory-step.active').classList.remove('active');\n    document.querySelector(\"#new-memory-step-\".concat(prevStepIdUpd)).classList.add('active');\n    applyProgress(prevStepId + 1, 0);\n    isStepFilled(prevStepIdUpd);\n    if (prevStepId == 0) prevStepBtn.classList.add('hidden');else prevStepBtn.setAttribute('data-prev', getPrevStepId(prevStepIdGlobal));\n    nextStepBtn.setAttribute('data-next', nextStepIdGlobal);\n  });\n};\n\n/**\r\n * Check if specific step is ready.\r\n *\r\n * @param stepId\r\n */\nvar isStepFilled = function isStepFilled() {\n  var stepId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var cb,\n    // Callback function for each step, returns true if step is ready, otherwise - false.\n    stepForProgress = 0,\n    percentage = 100,\n    falsePercentage = 0;\n  switch (stepId) {\n    case 1:\n      cb = _step_1__WEBPACK_IMPORTED_MODULE_2__.checkStep1;\n      nextStepIdGlobal = isMilitaryTheme() ? '2-military' : 2;\n      prevStepIdGlobal = 1;\n      stepForProgress = 1;\n      break;\n    case 2:\n      cb = _step_2__WEBPACK_IMPORTED_MODULE_3__.checkStep2;\n      nextStepIdGlobal = 3;\n      prevStepIdGlobal = 2;\n      stepForProgress = 2;\n      falsePercentage = isMilitaryTheme() ? 66 : 0;\n      break;\n    case '2-military':\n      cb = _step_2_military__WEBPACK_IMPORTED_MODULE_7__.checkStep2Military;\n      nextStepIdGlobal = '3-military';\n      prevStepIdGlobal = '2-military';\n      percentage = 33;\n      stepForProgress = 2;\n      break;\n    case '3-military':\n      cb = _step_3_military__WEBPACK_IMPORTED_MODULE_8__.checkStep3Military;\n      nextStepIdGlobal = 2;\n      prevStepIdGlobal = '3-military';\n      percentage = 66;\n      falsePercentage = 33;\n      stepForProgress = 2;\n      break;\n    case 3:\n      cb = _step_3__WEBPACK_IMPORTED_MODULE_4__.checkStep3;\n      nextStepIdGlobal = 4;\n      prevStepIdGlobal = 3;\n      stepForProgress = 3;\n      break;\n    case 4:\n      cb = _step_4__WEBPACK_IMPORTED_MODULE_5__.checkStep4;\n      nextStepIdGlobal = 5;\n      prevStepIdGlobal = 4;\n      stepForProgress = 4;\n      break;\n    case 5:\n      cb = _step_5__WEBPACK_IMPORTED_MODULE_6__.checkStep5;\n      nextStepIdGlobal = 6;\n      prevStepIdGlobal = 5;\n      stepForProgress = 5;\n      break;\n    default:\n      cb = _step_0__WEBPACK_IMPORTED_MODULE_1__.checkStep0;\n      nextStepIdGlobal = 1;\n      prevStepIdGlobal = 0;\n  }\n  if (cb()) {\n    applyProgress(stepForProgress, percentage);\n    allowNextStep(nextStepIdGlobal);\n  } else {\n    applyProgress(stepForProgress, falsePercentage);\n    disallowNextStep();\n  }\n};\n\n/**\r\n * Do some actions on the last step.\r\n */\nvar theLastStep = function theLastStep() {\n  var step1 = localStorage.getItem('ih-step-1') ? JSON.parse(localStorage.getItem('ih-step-1')) : null;\n  if (!step1) return;\n  var thumb = step1.cropped || '',\n    firstName = step1.firstname,\n    middleName = step1.fathername,\n    lastName = step1.lastname,\n    bornAtObj = new Date(step1['date-of-birth']),\n    bornDay = bornAtObj.getDate() < 10 ? \"0\".concat(bornAtObj.getDate()) : bornAtObj.getDate(),\n    bornMonth = bornAtObj.getMonth() + 1 < 10 ? \"0\".concat(bornAtObj.getMonth() + 1) : bornAtObj.getMonth() + 1,\n    bornAt = \"\".concat(bornDay, \".\").concat(bornMonth, \".\").concat(bornAtObj.getFullYear()),\n    diedAtObj = new Date(step1['date-of-death']),\n    diedDay = diedAtObj.getDate() < 10 ? \"0\".concat(diedAtObj.getDate()) : diedAtObj.getDate(),\n    diedMonth = diedAtObj.getMonth() + 1 < 10 ? \"0\".concat(diedAtObj.getMonth() + 1) : diedAtObj.getMonth() + 1,\n    diedAt = \"\".concat(diedDay, \".\").concat(diedMonth, \".\").concat(diedAtObj.getFullYear());\n\n  // Push data to HTML.\n  if (thumb) {\n    document.querySelector('.page-created-thumb-img').innerHTML = \"<img src=\\\"\".concat(thumb, \"\\\" alt=\\\"\").concat(firstName, \" \").concat(middleName, \" \").concat(lastName, \"\\\" />\");\n  }\n  document.querySelector('.page-created-firstname').innerHTML = \"\".concat(firstName, \" \").concat(middleName);\n  document.querySelector('.page-created-lastname').innerHTML = lastName;\n  document.querySelector('.page-created-dates').innerHTML = \"\".concat(bornAt, \" - \").concat(diedAt);\n\n  // Hide footer, clean localStorage.\n  document.querySelector('.new-memory-footer').classList.add('hidden');\n  localStorage.removeItem('ih-step-0');\n  localStorage.removeItem('ih-step-1');\n  localStorage.removeItem('ih-step-2');\n  localStorage.removeItem('ih-step-3');\n  localStorage.removeItem('ih-step-4');\n  localStorage.removeItem('ih-step-5');\n};\nvar getPrevStepId = function getPrevStepId(stepId) {\n  switch (stepId) {\n    case 2:\n      return isMilitaryTheme() ? '3-military' : 1;\n    case '2-military':\n      return 1;\n    case '3-military':\n      return '2-military';\n    case 3:\n      return 2;\n    case 4:\n      return 3;\n    case 5:\n      return 4;\n    default:\n      return 0;\n  }\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/common.js?");

/***/ }),

/***/ "./src/js/new-memory/step-0.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-0.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkStep0: function() { return /* binding */ checkStep0; },\n/* harmony export */   selectTheme: function() { return /* binding */ selectTheme; }\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n\n\n/**\r\n * Theme selection.\r\n */\nvar selectTheme = function selectTheme() {\n  var themes = document.querySelectorAll('.new-memory-theme');\n  if (!themes.length) return;\n  themes.forEach(function (theme) {\n    theme.addEventListener('click', function () {\n      var alreadySelectedTheme = document.querySelector('.new-memory-theme.active');\n      if (alreadySelectedTheme) alreadySelectedTheme.classList.remove('active');\n      theme.classList.add('active');\n      localStorage.setItem('ih-step-0', JSON.stringify({\n        theme: theme.dataset.value\n      }));\n      (0,_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)();\n    });\n  });\n};\n\n/**\r\n * Check if step is done.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep0 = function checkStep0() {\n  var activeTheme = document.querySelector('.new-memory-theme.active');\n  if (!activeTheme) return false;\n  var theme = activeTheme.dataset.value;\n  localStorage.setItem('ih-step-0', JSON.stringify({\n    theme: theme\n  }));\n  if (theme === 'military') document.body.classList.add('memory-page-theme-military');else document.body.classList.remove('memory-page-theme-military');\n  return true;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-0.js?");

/***/ }),

/***/ "./src/js/new-memory/step-1.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-1.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMainFormValidation: function() { return /* binding */ addMainFormValidation; },\n/* harmony export */   checkStep1: function() { return /* binding */ checkStep1; },\n/* harmony export */   selectLanguage: function() { return /* binding */ selectLanguage; },\n/* harmony export */   uploadMainPhoto: function() { return /* binding */ uploadMainPhoto; }\n/* harmony export */ });\n/* harmony import */ var cropperjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cropperjs */ \"./node_modules/cropperjs/dist/cropper.js\");\n/* harmony import */ var cropperjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cropperjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var body_scroll_lock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! body-scroll-lock */ \"./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js\");\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n\n\n\n\nvar stepData = localStorage.getItem('ih-step-1') ? JSON.parse(localStorage.getItem('ih-step-1')) : {\n  lang: 'uk'\n};\nvar cropper;\n\n/**\r\n * Select memory language.\r\n */\nvar selectLanguage = function selectLanguage() {\n  var langs = document.querySelectorAll('.new-memory-lang');\n  if (!langs.length) return;\n  langs.forEach(function (lang) {\n    lang.addEventListener('click', function () {\n      document.querySelector('.new-memory-lang.active').classList.remove('active');\n      lang.classList.add('active');\n      stepData.lang = lang.dataset.lang;\n      localStorage.setItem('ih-step-1', JSON.stringify(stepData));\n    });\n  });\n};\n\n/**\r\n * Upload main photo in Main info form, Step 1.\r\n */\nvar uploadMainPhoto = function uploadMainPhoto() {\n  var popup = document.querySelector('.photo-popup'),\n    photo = document.querySelector('#photo'),\n    img = document.querySelector('.popup-photo'),\n    saveBtn = document.querySelector('.popup-save-photo'),\n    mainPhotoNameEl = document.querySelector('.new-memory-main-info .filename');\n  var mainPhotoName;\n  if (!popup || !photo || !img || !saveBtn || !mainPhotoNameEl) return;\n  photo.addEventListener('change', function () {\n    var fReader = new FileReader(),\n      file = photo.files[0];\n    mainPhotoName = file.name;\n    fReader.readAsDataURL(file);\n    fReader.onload = function (e) {\n      img.src = e.target.result;\n      popup.classList.remove('hidden');\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setTargetElement)('#photo-popup');\n      (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_1__.disableBodyScroll)((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.getTargetElement)(), {\n        reserveScrollBarGap: true\n      });\n      cropper = new (cropperjs__WEBPACK_IMPORTED_MODULE_0___default())(img, {\n        aspectRatio: 302 / 389,\n        movable: false,\n        rotatable: false,\n        scalable: false,\n        zoomable: false,\n        zoomOnTouch: false\n      });\n    };\n  });\n\n  // Close popup.\n  popup.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.className && (target.classList.contains('popup') || target.classList.contains('popup-discard-photo'))) {\n      popup.classList.add('hidden');\n      (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_1__.enableBodyScroll)((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.getTargetElement)());\n      if (cropper) cropper.destroy();\n    }\n  });\n\n  // Save cropped image.\n  saveBtn.addEventListener('click', function () {\n    var formData = new FormData();\n    popup.classList.add('hidden');\n    (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_1__.enableBodyScroll)((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.getTargetElement)());\n    formData.append('action', 'ih_ajax_upload_main_photo');\n    cropper.getCroppedCanvas().toBlob(function (blob) {\n      if ((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.checkAjaxWorkingStatus)()) return;\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setAjaxWorkingStatus)(true);\n      formData.append('cropped', blob, mainPhotoName);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.ihAjaxRequest)(formData).then(function (res) {\n        if (res) {\n          switch (res.success) {\n            case true:\n              mainPhotoNameEl.innerHTML = res.data.short_filename;\n              mainPhotoNameEl.closest('.label').classList.add('added');\n              stepData.cropped = res.data.url;\n              localStorage.setItem('ih-step-1', JSON.stringify(stepData));\n              if (checkStep1()) {\n                (0,_common__WEBPACK_IMPORTED_MODULE_3__.allowNextStep)(2);\n                (0,_common__WEBPACK_IMPORTED_MODULE_3__.applyProgress)(1);\n              } else {\n                (0,_common__WEBPACK_IMPORTED_MODULE_3__.disallowNextStep)();\n                (0,_common__WEBPACK_IMPORTED_MODULE_3__.applyProgress)(1, 0);\n              }\n              break;\n            case false:\n              console.error(res.data.msg);\n              break;\n          }\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setAjaxWorkingStatus)(false);\n        cropper.destroy();\n      });\n    });\n  });\n};\n\n/**\r\n * Validate Step 1 Main info form.\r\n */\nvar addMainFormValidation = function addMainFormValidation() {\n  var fields = document.querySelectorAll('.new-memory-main-info input:not([type=\"file\"])');\n  if (!fields.length) return;\n  fields.forEach(function (field) {\n    field.addEventListener('change', function (e) {\n      return checkFieldValue(e);\n    });\n    field.addEventListener('keyup', function (e) {\n      return checkFieldValue(e);\n    });\n    field.addEventListener('blur', function (e) {\n      return checkFieldValue(e);\n    });\n  });\n  var checkFieldValue = function checkFieldValue(e) {\n    var field = e.target,\n      value = field.value,\n      index = field.name;\n    if (!value) field.classList.add('error');else field.classList.remove('error');\n    stepData[index] = value;\n    localStorage.setItem('ih-step-1', JSON.stringify(stepData));\n    (0,_common__WEBPACK_IMPORTED_MODULE_3__.isStepFilled)(1);\n  };\n};\n\n/**\r\n * Check if Step 1 Main info form is valid.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep1 = function checkStep1() {\n  var fields = document.querySelectorAll('.new-memory-main-info input');\n  var isFormValid = true;\n  if (!fields.length) return false;\n\n  // Fill stepData again in the case localStorage was cleared.\n  stepData.lang = document.querySelector('.new-memory-lang.active').dataset.lang;\n  fields.forEach(function (field) {\n    var index = field.name,\n      value = field.value;\n    if (field.classList.contains('error') || field.required && !value) isFormValid = false;\n    stepData[index] = value;\n  });\n  localStorage.setItem('ih-step-1', JSON.stringify(stepData));\n  return isFormValid;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-1.js?");

/***/ }),

/***/ "./src/js/new-memory/step-2-military.js":
/*!**********************************************!*\
  !*** ./src/js/new-memory/step-2-military.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkStep2Military: function() { return /* binding */ checkStep2Military; },\n/* harmony export */   closeDropdown: function() { return /* binding */ closeDropdown; },\n/* harmony export */   openDropdown: function() { return /* binding */ openDropdown; },\n/* harmony export */   step2MilitaryFormValidation: function() { return /* binding */ step2MilitaryFormValidation; }\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n\nvar stepData = localStorage.getItem('ih-step-2-military') ? JSON.parse(localStorage.getItem('ih-step-2-military')) : {};\nvar step2MilitaryFormValidation = function step2MilitaryFormValidation() {\n  var fields = document.querySelectorAll('.new-memory-step-2-military input');\n  if (!fields.length) return;\n  fields.forEach(function (field) {\n    var label = field.closest('.label'),\n      options = label.querySelectorAll('.option');\n    var checkFieldValue = function checkFieldValue(e) {\n      var field = e.target,\n        value = field.value,\n        index = field.name;\n      if (!value) field.classList.add('error');else field.classList.remove('error');\n      stepData[index] = value;\n      localStorage.setItem('ih-step-2-military', JSON.stringify(stepData));\n      (0,_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)('2-military');\n    };\n    field.addEventListener('focus', openDropdown);\n    field.addEventListener('click', openDropdown);\n    field.addEventListener('input', checkFieldValue);\n    field.addEventListener('change', checkFieldValue);\n    field.addEventListener('keyup', checkFieldValue);\n    field.addEventListener('blur', checkFieldValue);\n    if (!options.length) return;\n\n    // Select option.\n    options.forEach(function (option) {\n      option.addEventListener('click', function () {\n        field.value = option.innerText;\n        setTimeout(function () {\n          return closeDropdown();\n        }, 10);\n      });\n    });\n  });\n  document.addEventListener('click', function (e) {\n    var target = e.target;\n    if (!target.closest('.label')) closeDropdown();\n  });\n};\nvar openDropdown = function openDropdown(e) {\n  var target = e.target,\n    label = target.closest('.label'),\n    dropdown = label.querySelector('.options');\n  closeDropdown();\n  if (!dropdown) return;\n  dropdown.classList.add('active');\n};\nvar closeDropdown = function closeDropdown() {\n  var dropdown = document.querySelector('.options.active');\n  if (dropdown) dropdown.classList.remove('active');\n};\n\n/**\r\n * Check if Step 2 Military is ready.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep2Military = function checkStep2Military() {\n  var selects = document.querySelectorAll('.new-memory-step-2-military .input-wrapper.select input');\n  var allIsSet = true;\n  if (!selects.length) return false;\n  selects.forEach(function (select) {\n    var name = select.name,\n      value = select.value;\n    stepData[name] = value;\n    if (!value) allIsSet = false;\n    localStorage.setItem('ih-step-2-military', JSON.stringify(stepData));\n  });\n  return allIsSet;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-2-military.js?");

/***/ }),

/***/ "./src/js/new-memory/step-2.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-2.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addSection: function() { return /* binding */ addSection; },\n/* harmony export */   checkStep2: function() { return /* binding */ checkStep2; },\n/* harmony export */   dragOrderSections: function() { return /* binding */ dragOrderSections; },\n/* harmony export */   removeContentSection: function() { return /* binding */ removeContentSection; },\n/* harmony export */   removeSidebarAddedSection: function() { return /* binding */ removeSidebarAddedSection; },\n/* harmony export */   sectionsContentInput: function() { return /* binding */ sectionsContentInput; },\n/* harmony export */   setActiveSectionContent: function() { return /* binding */ setActiveSectionContent; }\n/* harmony export */ });\n/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ \"./node_modules/sortablejs/modular/sortable.esm.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar stepData = localStorage.getItem('ih-step-2') ? JSON.parse(localStorage.getItem('ih-step-2')) : {};\nvar sectionsWrapper, militarySectionsWrapper, sectionsContent;\n\n/**\r\n * Add section to added sections list.\r\n */\nvar addSection = function addSection() {\n  sectionsWrapper = document.querySelector('.sections-sidebar');\n  militarySectionsWrapper = document.querySelector('.sections-military');\n  sectionsContent = document.querySelector('.sections-content');\n  if (!sectionsWrapper || !sectionsContent) return;\n  sectionsWrapper.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.closest('.section-add') || target.className && target.classList.contains('section-add')) {\n      var addedSectionsWrapper = document.querySelector('.sections-added-list'),\n        targetSection = target.closest('.section'),\n        imgUrl = targetSection.dataset.thumb || null,\n        clonedSection = targetSection.cloneNode(true),\n        clonedSectionContent = sectionsContent.querySelector('.section-content').cloneNode(true),\n        clonedTextarea = clonedSectionContent.querySelector('.section-content-text'),\n        randomId = Math.random() * 9999 + '_' + Math.random() * 9999;\n\n      // If a military section is clicked, but theme is not military - exit.\n      if (targetSection.classList.contains('section-military') && !document.body.classList.contains('memory-page-theme-military')) return;\n\n      // Replace in sidebar.\n      targetSection.remove();\n      addedSectionsWrapper.append(clonedSection);\n\n      // Add new content.\n      clonedSectionContent.querySelector('textarea').innerText = '';\n      clonedSectionContent.querySelector('.section-content-title').innerText = clonedSection.querySelector('.section-label').innerText;\n      // Change SVG IDs and so on.\n      clonedSectionContent.querySelector('[id^=\"content-drag-\"]').id = \"content-drag-\".concat(randomId);\n      clonedSectionContent.querySelector('[mask^=\"url(#content-drag-\"]').setAttribute('mask', \"url(#content-drag-\".concat(randomId, \")\"));\n      clonedSectionContent.querySelector('[id^=\"content-remove-\"]').id = \"content-remove-\".concat(randomId);\n      clonedSectionContent.querySelector('[mask^=\"url(#content-remove-\"]').setAttribute('mask', \"url(#content-remove-\".concat(randomId, \")\"));\n      clonedSectionContent.setAttribute('data-id', clonedSection.dataset.id);\n      clonedTextarea.value = ''; // Clear value.\n\n      // Delete photos in cloned section if they are exist.\n      if (clonedSectionContent.querySelector('.section-content-photos')) clonedSectionContent.querySelector('.section-content-photos').innerHTML = '';\n      sectionsContent.append(clonedSectionContent); // Push new section into the DOM.\n      window.scrollTo({\n        top: sectionsContent.getBoundingClientRect().top + window.scrollY\n      });\n\n      // If this is a section with a custom title.\n      if (imgUrl) {\n        clonedSectionContent.classList.add('custom');\n        clonedSectionContent.querySelector('.section-content-title').innerHTML = '<input class=\"section-content-title-input\" placeholder=\"Придумайте заголовок\" />';\n        clonedSectionContent.insertAdjacentHTML('beforeend', \"<img class=\\\"section-content-thumb\\\" src=\\\"\".concat(imgUrl, \"\\\" alt=\\\"\\\" />\"));\n      }\n      setTimeout(function () {\n        return clonedSectionContent.click();\n      }, 10); // Set it as active.\n      sectionsContentInput(); // Add event listeners.\n      checkIfAllSectionsContentSet();\n    }\n  });\n  uploadSectionPhoto();\n  deletePhoto();\n};\n\n/**\r\n * Remove section from sections list.\r\n */\nvar removeSidebarAddedSection = function removeSidebarAddedSection() {\n  if (!sectionsWrapper || !sectionsContent) return;\n  sectionsWrapper.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.closest('.section-remove') || target.className && target.classList.contains('.section-remove')) {\n      var _sectionsWrapper = document.querySelector('.sections-list'),\n        targetSection = target.closest('.section'),\n        sectionId = targetSection.dataset.id,\n        sectionsAdded = document.querySelectorAll('.sections-added-list .section'),\n        sectionContent = sectionsContent.querySelector(\".section-content[data-id=\\\"\".concat(sectionId, \"\\\"]\")),\n        isMilitary = targetSection.classList.contains('section-military');\n      if (!sectionsAdded.length || sectionsAdded.length < 2) return;\n\n      // Section content is not empty - double-check if User wants to delete it.\n      if (sectionContent.querySelector('.section-content-text').value && !confirm('Дійсно видалити цю секцію?')) return;\n      var clonedSection = targetSection.cloneNode(true);\n      clonedSection.querySelector('.section-label').innerText = clonedSection.dataset.title;\n      if (isMilitary && militarySectionsWrapper) militarySectionsWrapper.append(clonedSection);else _sectionsWrapper.append(clonedSection);\n      targetSection.remove();\n      sectionContent.remove();\n      for (var key in stepData) {\n        if (key == sectionId) delete stepData[key];\n      }\n      localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n      checkIfAllSectionsContentSet();\n    }\n  });\n};\n\n/**\r\n * Remove section from content.\r\n */\nvar removeContentSection = function removeContentSection() {\n  if (!sectionsWrapper || !sectionsContent) return;\n  sectionsContent.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.closest('.section-remove') || target.className && target.classList.contains('.section-remove')) {\n      var _sectionsWrapper2 = document.querySelector('.sections-list'),\n        targetContent = target.closest('.section-content'),\n        sectionId = targetContent.dataset.id,\n        targetSection = document.querySelector(\".sections-added-list .section[data-id=\\\"\".concat(sectionId, \"\\\"]\")),\n        sectionsAdded = document.querySelectorAll('.sections-added-list .section'),\n        isMilitary = targetSection.classList.contains('section-military');\n      if (!sectionsAdded.length || sectionsAdded.length < 2) return;\n\n      // Section content is not empty - double-check if User wants to delete it.\n      if (targetContent.querySelector('.section-content-text').value && !confirm('Дійсно видалити цю секцію?')) return;\n      var clonedSection = targetSection.cloneNode(true);\n      if (isMilitary && militarySectionsWrapper) militarySectionsWrapper.append(clonedSection);else _sectionsWrapper2.append(clonedSection);\n      targetSection.remove();\n      targetContent.remove();\n      for (var key in stepData) {\n        if (key == sectionId) delete stepData[key];\n      }\n      localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n      checkIfAllSectionsContentSet();\n    }\n  });\n};\n\n/**\r\n * Set active section content.\r\n */\nvar setActiveSectionContent = function setActiveSectionContent() {\n  if (!sectionsContent) return;\n  sectionsContent.addEventListener('click', function (e) {\n    var target = e.target;\n    if (target.closest('.section-content') || target.className && target.classList.contains('section-content')) {\n      if (target.className && (target.classList.contains('section-content-photo-delete') || target.closest('.popup-confirm') || target.classList.contains('section-content-form-add') || target.closest('.section-content-form-add'))) return;\n      var targetSection = target.closest('.section-content'),\n        activeSection = sectionsContent.querySelector('.section-content.active');\n      if (activeSection) activeSection.classList.remove('active');\n      if (targetSection) targetSection.classList.add('active');\n\n      // Focus textarea if target is not input (like custom title).\n      if (target.tagName !== 'INPUT') targetSection.querySelector('.section-content-text').focus();\n    }\n  });\n\n  // Click outside - set section inactive.\n  document.addEventListener('click', function (e) {\n    var target = e.target,\n      activeSection = sectionsContent.querySelector('.section-content.active');\n    if (!activeSection) return;\n    if (!target.closest('.section-content') && target.className && !target.classList.contains('.section-content')) activeSection.classList.remove('active');\n  });\n};\n\n/**\r\n * Re-order sections with drag-and-drop events.\r\n */\nvar dragOrderSections = function dragOrderSections() {\n  var wrapper = document.querySelector('.sections-added-list');\n  sortablejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create(wrapper, {\n    handle: '.section-drag',\n    onEnd: function onEnd(evt) {\n      var item = evt.item,\n        itemId = item.dataset.id,\n        oldIndex = evt.oldIndex,\n        newIndex = evt.newIndex,\n        step = oldIndex < newIndex ? 2 : 1,\n        content = sectionsContent.querySelector(\".section-content[data-id=\\\"\".concat(itemId, \"\\\"]\")),\n        cloned = content.cloneNode(true),\n        putBefore = sectionsContent.querySelector(\".section-content:nth-child(\".concat(newIndex + step, \")\"));\n      if (putBefore) putBefore.parentNode.insertBefore(cloned, putBefore);else sectionsContent.append(cloned);\n      content.remove();\n      checkSectionsIndexes();\n    }\n  });\n  sortablejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create(sectionsContent, {\n    handle: '.section-drag',\n    onEnd: function onEnd(evt) {\n      var item = evt.item,\n        itemId = item.dataset.id,\n        oldIndex = evt.oldIndex,\n        newIndex = evt.newIndex,\n        step = oldIndex < newIndex ? 2 : 1,\n        section = wrapper.querySelector(\".section[data-id=\\\"\".concat(itemId, \"\\\"]\")),\n        cloned = section.cloneNode(true),\n        putBefore = wrapper.querySelector(\".section:nth-child(\".concat(newIndex + step, \")\"));\n      if (putBefore) putBefore.parentNode.insertBefore(cloned, putBefore);else wrapper.append(cloned);\n      section.remove();\n      checkSectionsIndexes();\n    }\n  });\n};\nvar checkSectionsIndexes = function checkSectionsIndexes() {\n  var sections = document.querySelectorAll('.section-content');\n  if (!sections.length) return;\n  sections.forEach(function (section, i) {\n    return stepData[section.dataset.id].position = i;\n  });\n  localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n};\n\n/**\r\n * Check if User could be allowed to go further - if all textareas are set.\r\n */\nvar sectionsContentInput = function sectionsContentInput() {\n  var textareas = document.querySelectorAll('.section-content-text');\n  if (!textareas.length) return;\n  textareas.forEach(function (area) {\n    var titleInput = area.closest('.section-content').querySelector('.section-content-title-input');\n\n    // Remove event listeners.\n    area.removeEventListener('keyup', checkIfAllSectionsContentSet);\n    area.removeEventListener('change', checkIfAllSectionsContentSet);\n    area.removeEventListener('blur', checkIfAllSectionsContentSet);\n    // Add event listeners.\n    area.addEventListener('keyup', checkIfAllSectionsContentSet);\n    area.addEventListener('change', checkIfAllSectionsContentSet);\n    area.addEventListener('blur', checkIfAllSectionsContentSet);\n    if (titleInput) {\n      // Remove event listeners.\n      titleInput.removeEventListener('keyup', checkIfAllSectionsContentSet);\n      titleInput.removeEventListener('change', checkIfAllSectionsContentSet);\n      titleInput.removeEventListener('blur', checkIfAllSectionsContentSet);\n      titleInput.removeEventListener('keyup', duplicateValueToSidebarSection);\n      titleInput.removeEventListener('change', duplicateValueToSidebarSection);\n      // Add event listeners.\n      titleInput.addEventListener('keyup', checkIfAllSectionsContentSet);\n      titleInput.addEventListener('change', checkIfAllSectionsContentSet);\n      titleInput.addEventListener('blur', checkIfAllSectionsContentSet);\n      titleInput.addEventListener('keyup', duplicateValueToSidebarSection);\n      titleInput.addEventListener('change', duplicateValueToSidebarSection);\n    }\n  });\n};\n\n/**\r\n * If all textareas are set - can go further.\r\n */\nvar checkIfAllSectionsContentSet = function checkIfAllSectionsContentSet() {\n  return (0,_common__WEBPACK_IMPORTED_MODULE_1__.isStepFilled)(2);\n};\n\n/**\r\n * Check if step 2 is ready.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep2 = function checkStep2() {\n  var textareas = document.querySelectorAll('.section-content-text');\n  var allIsSet = true;\n  if (!textareas.length) return;\n  textareas.forEach(function (area, i) {\n    var section = area.closest('.section-content'),\n      title = section.querySelector('.section-content-title'),\n      titleInput = title.querySelector('.section-content-title-input'),\n      value = area.value,\n      index = section.dataset.id,\n      isCustom = section.classList.contains('custom') ? 1 : '',\n      photos = section.querySelectorAll('.section-content-photo');\n    if (titleInput) stepData[index] = _objectSpread(_objectSpread({}, stepData[index]), {}, {\n      title: titleInput.value\n    });else stepData[index] = _objectSpread(_objectSpread({}, stepData[index]), {}, {\n      title: title.innerText\n    });\n\n    // If textarea or title input is not set.\n    if (!value || titleInput && !titleInput.value) allIsSet = false;\n    stepData[index].text = value;\n    stepData[index].position = i;\n    stepData[index].custom = isCustom;\n    stepData[index].photos = [];\n    if (photos.length) photos.forEach(function (photo) {\n      return stepData[index].photos.push(photo.dataset.id);\n    });\n    localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n  });\n  return allIsSet;\n};\n\n/**\r\n * Set custom section title in the sidebar the same as in the title input.\r\n *\r\n * @param {Event} e\r\n */\nvar duplicateValueToSidebarSection = function duplicateValueToSidebarSection(e) {\n  var target = e.target,\n    value = target.value,\n    id = target.closest('.section-content').dataset.id,\n    sidebarSectionTitle = document.querySelector(\".sections-added-list .section[data-id=\\\"\".concat(id, \"\\\"] .section-label\"));\n  sidebarSectionTitle.innerHTML = value || 'Свій заголовок';\n};\n\n/**\r\n * Delete photo from a section content.\r\n */\nvar deletePhoto = function deletePhoto() {\n  if (!sectionsContent) return;\n  var popupConfirm = sectionsContent.querySelector('.popup-confirm.delete');\n  sectionsContent.addEventListener('click', function (e) {\n    e.stopPropagation();\n    var target = e.target,\n      clientX = e.clientX < 200 ? 200 : e.clientX,\n      clientY = e.clientY;\n    if (!(target.className && target.classList.contains('section-content-photo-delete')) || !popupConfirm) return;\n    var id = target.dataset.id,\n      popupConfirmClone = popupConfirm.cloneNode(true);\n\n    // If popup already exists - exit.\n    if (target.classList.contains('active')) return;\n    target.classList.add('active');\n    target.appendChild(popupConfirmClone);\n    popupConfirmClone.style.left = \"\".concat(clientX, \"px\");\n    popupConfirmClone.style.top = \"\".concat(clientY, \"px\");\n    popupConfirmClone.classList.remove('hidden');\n    document.body.classList.add('overflow-hidden');\n    popupConfirmClone.querySelector('.popup-confirm-no').addEventListener('click', function () {\n      popupConfirmClone.remove();\n      document.body.classList.remove('overflow-hidden');\n      target.classList.remove('active');\n    });\n    popupConfirmClone.querySelector('.popup-confirm-yes').addEventListener('click', function () {\n      if ((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.checkAjaxWorkingStatus)()) return;\n      var formData = new FormData();\n      formData.append('action', 'ih_ajax_delete_memory_photo');\n      formData.append('id', id);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.ihAjaxRequest)(formData).then(function (res) {\n        if (res) {\n          switch (res.success) {\n            case true:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(res.data.msg);\n              target.closest('.section-content-photo').remove();\n              for (var _i = 0, _Object$keys = Object.keys(stepData); _i < _Object$keys.length; _i++) {\n                var key = _Object$keys[_i];\n                if (stepData[key].photos) {\n                  for (var i = 0; i < stepData[key].photos.length; i++) {\n                    if (stepData[key].photos[i] == id) stepData[key].photos.splice(i, 1);\n                  }\n                }\n              }\n              localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n              break;\n            case false:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(res.data.msg, 'error');\n              break;\n          }\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setAjaxWorkingStatus)(false);\n      });\n      popupConfirmClone.remove();\n      document.body.classList.remove('overflow-hidden');\n    });\n  });\n};\n\n/**\r\n * Upload section photo.\r\n */\nvar uploadSectionPhoto = function uploadSectionPhoto() {\n  if (!sectionsContent) return;\n  var fileInstance;\n  var handlePhotosUpload = function handlePhotosUpload(e) {\n    fileInstance = _toConsumableArray(e.target.files);\n    if (!fileInstance.length) return;\n    if (fileInstance[0].size > 50 * _common_global__WEBPACK_IMPORTED_MODULE_2__.BYTES_IN_MB) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(\"\\u041D\\u0435 \\u0432\\u0434\\u0430\\u043B\\u043E\\u0441\\u044F \\u0437\\u0430\\u0432\\u0430\\u043D\\u0442\\u0430\\u0436\\u0438\\u0442\\u0438 \\u0444\\u043E\\u0442\\u043E \".concat(fileInstance[0].name), 'error');\n      return false;\n    }\n    var sectionContent = e.target.closest('.section-content'),\n      sectionContentId = sectionContent.dataset.id;\n    var processingUploadMediaPhoto = function processingUploadMediaPhoto(file, area) {\n      if (!file || !area) return;\n      var formData = new FormData();\n      formData.append('file', file);\n      formData.append('action', 'ih_ajax_upload_section_photo');\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.addLoader)(sectionContent);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.ihAjaxRequest)(formData).then(function (res) {\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.removeLoader)(sectionContent);\n        if (res) {\n          switch (res.success) {\n            case true:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(res.data.msg);\n              area.insertAdjacentHTML('beforeend', res.data.image);\n              var attachId = res.data.attach_id;\n\n              // Search section by its ID and add attached photo ID to its photos array.\n              for (var _i2 = 0, _Object$keys2 = Object.keys(stepData); _i2 < _Object$keys2.length; _i2++) {\n                var key = _Object$keys2[_i2];\n                if (key == sectionContentId) stepData[key].photos.push(attachId);\n              }\n              localStorage.setItem('ih-step-2', JSON.stringify(stepData));\n              break;\n            case false:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(res.data.msg, 'error');\n              break;\n          }\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setAjaxWorkingStatus)(false);\n      });\n    };\n    if (fileInstance[0].type.startsWith('image/')) processingUploadMediaPhoto(fileInstance[0], sectionContent.querySelector('.section-content-photos'));else (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showNotification)(\"\\u0422\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F - \\u0444\\u0430\\u0439\\u043B \".concat(fileInstance[0].name, \" \\u043D\\u0435 \\u0454 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F\\u043C\"), 'warning');\n  };\n  sectionsContent.addEventListener('click', function (e) {\n    e.stopPropagation();\n    var target = e.target;\n    if (!target.className || !(target.classList.contains('section-content-form-add') || target.closest('.section-content-form-add'))) return;\n    var input = target.closest('.section-content-form').querySelector('input.section-add-photo');\n    if (!input) return;\n    input.removeEventListener('change', handlePhotosUpload);\n    input.addEventListener('change', handlePhotosUpload);\n  });\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-2.js?");

/***/ }),

/***/ "./src/js/new-memory/step-3-military.js":
/*!**********************************************!*\
  !*** ./src/js/new-memory/step-3-military.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addReward: function() { return /* binding */ addReward; },\n/* harmony export */   checkStep3Military: function() { return /* binding */ checkStep3Military; }\n/* harmony export */ });\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\n/* harmony import */ var _step_2_military__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./step-2-military */ \"./src/js/new-memory/step-2-military.js\");\n\n\nvar addRewardButtons = document.querySelectorAll('button.add-reward'),\n  titleButton = document.querySelector('#new-memory-step-3-military .new-memory-step-title .add-reward'),\n  noRewardsBody = document.querySelector('.no-rewards-body'),\n  hasRewardsBody = document.querySelector('.has-rewards'),\n  rewardsMainWrap = document.querySelector('.rewards-main-wrap'),\n  rewardsArea = document.querySelector('.rewards-area'),\n  searchForm = document.querySelector('form.rewards-search'),\n  search = document.querySelector('#search-reward'),\n  rewardForm = document.querySelector('.reward-popup-form'),\n  decline = document.querySelector('.reward-popup-form-decline'),\n  rewardPopupText = document.querySelector('.reward-popup-text');\n\n// Reward popup.\nvar popup = rewardsMainWrap.querySelector('.reward-popup'),\n  popupReward = popup.querySelector('.reward-preview'),\n  popupNoRewardThumb = popupReward.querySelector('.reward-preview-no-reward-thumb'),\n  popupRewardThumb = popupReward.querySelector('.reward-preview-thumb'),\n  popupRewardTitle = popupReward.querySelector('.reward-preview-title'),\n  rewardPopupTextEdict = rewardPopupText.querySelector('.reward-popup-text-edict'),\n  rewardPopupTextNumber = rewardPopupText.querySelector('.reward-popup-text-number'),\n  rewardPopupTextDate = rewardPopupText.querySelector('.reward-popup-text-date'),\n  rewardPopupTextFor = rewardPopupText.querySelector('.reward-popup-text-for'),\n  rewardPopupTextPosthumously = rewardPopupText.querySelector('.reward-popup-text-posthumously'),\n  textAfterNumber = rewardPopupText.querySelector('.reward-popup-text-number-after'),\n  textAfterDate = rewardPopupText.querySelector('.reward-popup-text-date-after'),\n  rewardPopupCustomText = popup.querySelector('.reward-popup-custom');\n\n// Reward popup inputs.\nvar customLabel = popup.querySelector('.label-reward-custom'),\n  customInput = popup.querySelector('#reward-custom'),\n  edictInput = popup.querySelector('#edict'),\n  numberInput = popup.querySelector('#reward-number'),\n  dateInput = popup.querySelector('#reward-date'),\n  forInput = popup.querySelector('#reward-for-what'),\n  posthumously = popup.querySelector('#posthumously');\nvar addReward = function addReward() {\n  if (!addRewardButtons.length || !hasRewardsBody || !noRewardsBody || !rewardsMainWrap || !rewardsArea || !searchForm || !search) return;\n\n  // Show all rewards wrap on button click.\n  addRewardButtons.forEach(function (btn) {\n    btn.addEventListener('click', function (e) {\n      e.preventDefault();\n      hasRewardsBody.classList.add('hidden');\n      noRewardsBody.classList.add('hidden');\n      rewardsMainWrap.classList.remove('hidden');\n    });\n  });\n\n  // Click on a reward.\n  rewardsMainWrap.addEventListener('click', function (e) {\n    var target = e.target,\n      preview = target.closest('.reward-preview');\n    if (!preview || !popup) return;\n    var activePreview = document.querySelector('.reward-preview.active'),\n      breadcrumbs = document.querySelector('.rewards-sidebar-breadcrumbs'),\n      previewThumb = preview.querySelector('.reward-preview-thumb img').cloneNode(),\n      previewTitle = preview.querySelector('.reward-preview-title').innerText;\n    if (activePreview) activePreview.classList.remove('active');\n    popupReward.setAttribute('data-id', preview.dataset.id);\n    popupRewardThumb.innerHTML = '';\n    popupNoRewardThumb.classList.add('hidden');\n    popupRewardThumb.classList.remove('hidden');\n    popupRewardThumb.appendChild(previewThumb);\n    popupRewardTitle.classList.remove('hidden');\n    popupRewardTitle.innerText = previewTitle;\n    preview.classList.add('active');\n    popup.classList.remove('hidden');\n    if (breadcrumbs) {\n      breadcrumbs.querySelector('.active').classList.remove('active');\n      breadcrumbs.querySelector('span:last-child').classList.add('active');\n    }\n    window.scrollTo({\n      top: 0,\n      left: 0\n    });\n  });\n\n  // Close reward popup.\n  if (decline) {\n    decline.addEventListener('click', function (e) {\n      e.preventDefault();\n      var activePreview = document.querySelector('.reward-preview.active'),\n        breadcrumbs = document.querySelector('.rewards-sidebar-breadcrumbs');\n      if (activePreview) activePreview.classList.remove('active');\n      if (breadcrumbs) {\n        breadcrumbs.querySelector('.active').classList.remove('active');\n        breadcrumbs.querySelector('span:first-child').classList.add('active');\n      }\n      cleanRewardPopup();\n      rewardsMainWrap.classList.add('hidden');\n      if (!hasRewardsBody.querySelectorAll('.reward-preview').length) noRewardsBody.classList.remove('hidden');else hasRewardsBody.classList.remove('hidden');\n    });\n  }\n\n  // Filter callback.\n  var filter = function filter() {\n    if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n    var formData = new FormData(),\n      activeBtn = document.querySelector('.rewards-type-filter.active');\n    formData.append('action', 'ih_ajax_filter_rewards');\n    formData.append('slug', activeBtn ? activeBtn.dataset.slug : '');\n    formData.append('s', search.value);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.addLoader)(rewardsArea);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.removeLoader)(rewardsArea);\n      if (res) {\n        switch (res.success) {\n          case true:\n            rewardsArea.innerHTML = res.data.structure;\n            window.scrollTo({\n              top: rewardsArea.getBoundingClientRect().top + window.scrollY,\n              behavior: 'smooth'\n            });\n            break;\n          case false:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n            break;\n        }\n      }\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    });\n  };\n\n  // Click on a rewards type button to filter.\n  var rewardsTypes = document.querySelectorAll('.rewards-type-filter');\n  if (rewardsTypes.length) {\n    rewardsTypes.forEach(function (btn) {\n      btn.addEventListener('click', function (e) {\n        e.preventDefault();\n\n        // This button is already active - remove this filter.\n        if (btn.classList.contains('active')) {\n          btn.classList.remove('active');\n        } else {\n          var activeBtn = document.querySelector('.rewards-type-filter.active');\n          if (activeBtn) activeBtn.classList.remove('active');\n          btn.classList.add('active');\n        }\n        filter();\n        btn.blur();\n      });\n    });\n  }\n\n  // Filter rewards when typing in a search field.\n  search.addEventListener('input', (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.customDebounce)(filter));\n\n  // Search form submit - filter rewards.\n  searchForm.addEventListener('submit', function (e) {\n    e.preventDefault();\n    filter();\n  });\n  if (edictInput) {\n    edictInput.addEventListener('focus', _step_2_military__WEBPACK_IMPORTED_MODULE_1__.openDropdown);\n    edictInput.addEventListener('click', _step_2_military__WEBPACK_IMPORTED_MODULE_1__.openDropdown);\n    var label = edictInput.closest('.label'),\n      options = label.querySelectorAll('.option');\n    if (options.length) {\n      options.forEach(function (option) {\n        option.addEventListener('click', function () {\n          var text = option.innerText;\n          edictInput.value = text;\n          setTimeout(function () {\n            return (0,_step_2_military__WEBPACK_IMPORTED_MODULE_1__.closeDropdown)();\n          }, 10);\n          if (!rewardPopupText) return;\n          rewardPopupTextEdict.innerText = text;\n        });\n      });\n    }\n  }\n  document.addEventListener('click', function (e) {\n    var target = e.target;\n    if (!target.closest('.label')) (0,_step_2_military__WEBPACK_IMPORTED_MODULE_1__.closeDropdown)();\n  });\n  numberInput.addEventListener('input', function () {\n    var val = numberInput.value;\n    if (!val) {\n      textAfterNumber.classList.add('hidden');\n      return;\n    }\n    rewardPopupTextNumber.innerText = \"\\u2116 \".concat(val);\n    textAfterNumber.classList.remove('hidden');\n  });\n  dateInput.addEventListener('input', function () {\n    var val = dateInput.value;\n    if (!val) {\n      textAfterDate.classList.add('hidden');\n      return;\n    }\n    rewardPopupTextDate.innerText = (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.formatDate)(val);\n    textAfterDate.classList.remove('hidden');\n  });\n  forInput.addEventListener('input', function () {\n    var val = forInput.value;\n    if (!val) return;\n    rewardPopupTextFor.innerText = val;\n  });\n  posthumously.addEventListener('change', function () {\n    if (posthumously.checked) rewardPopupTextPosthumously.classList.remove('hidden');else rewardPopupTextPosthumously.classList.add('hidden');\n  });\n  rewardForm.addEventListener('submit', function (e) {\n    e.preventDefault();\n    if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n    var formData = new FormData(rewardForm),\n      rewardId = popupReward.dataset.id;\n    formData.append('action', 'ih_ajax_add_reward');\n    formData.append('id', rewardId);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.addLoader)(rewardForm);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.removeLoader)(rewardForm);\n      if (res) {\n        switch (res.success) {\n          case true:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg);\n            hasRewardsBody.innerHTML = res.data.rewards;\n            hasRewardsBody.classList.remove('hidden');\n            rewardsMainWrap.classList.add('hidden');\n            titleButton.classList.remove('hidden');\n            cleanRewardPopup();\n            break;\n          case false:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n            break;\n        }\n      }\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    });\n  });\n  addCustomReward();\n  deleteReward();\n  editReward();\n};\nvar addCustomReward = function addCustomReward() {\n  var btn = document.querySelector('button.add-custom-reward');\n  if (!btn) return;\n  btn.addEventListener('click', function () {\n    popupReward.setAttribute('data-id', '');\n    popupRewardThumb.classList.add('hidden');\n    popupNoRewardThumb.classList.remove('hidden');\n    popupRewardTitle.classList.add('hidden');\n    popup.classList.remove('hidden');\n    customLabel.classList.remove('hidden');\n    if (rewardPopupCustomText) rewardPopupCustomText.classList.remove('hidden');\n    window.scrollTo({\n      top: 0,\n      left: 0\n    });\n    btn.blur();\n  });\n};\n\n/**\r\n * Delete reward.\r\n */\nvar deleteReward = function deleteReward() {\n  var popupConfirm = document.querySelector('.popup-confirm.delete');\n  if (!hasRewardsBody || !popupConfirm) return;\n  hasRewardsBody.addEventListener('click', function (e) {\n    var target = e.target,\n      clientX = e.clientX < 200 ? 200 : e.clientX,\n      clientY = e.clientY;\n    if (!target.className || !target.classList.contains('reward-preview-delete') || !target.closest('.reward-preview-delete')) return;\n\n    // If we are here - delete button was clicked. Show popup.\n    var buttonsWrap = target.closest('.reward-preview-actions');\n\n    // If popup already exists - exit.\n    if (buttonsWrap.classList.contains('active')) return;\n    var popupConfirmClone = popupConfirm.cloneNode(true);\n    buttonsWrap.classList.add('active');\n    buttonsWrap.appendChild(popupConfirmClone);\n    popupConfirmClone.style.left = \"\".concat(clientX, \"px\");\n    popupConfirmClone.style.top = \"\".concat(clientY, \"px\");\n    popupConfirmClone.classList.remove('hidden');\n    document.body.classList.add('overflow-hidden');\n    popupConfirmClone.querySelector('.popup-confirm-no').addEventListener('click', function () {\n      popupConfirmClone.remove();\n      document.body.classList.remove('overflow-hidden');\n      buttonsWrap.classList.remove('active');\n    });\n    popupConfirmClone.querySelector('.popup-confirm-yes').addEventListener('click', function () {\n      if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n      var reward = target.closest('.reward-preview'),\n        memoryId = reward.dataset.id || '',\n        formData = new FormData();\n      formData.append('action', 'ih_ajax_delete_reward');\n      formData.append('id', memoryId);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n        buttonsWrap.classList.remove('active');\n        if (res) {\n          switch (res.success) {\n            case true:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg);\n              reward.remove();\n\n              // If there are no more rewards - show No Rewards screen.\n              if (!hasRewardsBody.querySelectorAll('.reward-preview').length) {\n                hasRewardsBody.classList.add('hidden');\n                titleButton.classList.add('hidden');\n                document.querySelector('.no-rewards-body').classList.remove('hidden');\n              }\n              break;\n            case false:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n              break;\n          }\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n      });\n      popupConfirmClone.remove();\n      document.body.classList.remove('overflow-hidden');\n    });\n  });\n};\n\n/**\r\n * Edit reward.\r\n */\nvar editReward = function editReward() {\n  if (!hasRewardsBody) return;\n  hasRewardsBody.addEventListener('click', function (e) {\n    var target = e.target;\n    if (!target.className || !target.classList.contains('reward-preview-edit') || !target.closest('.reward-preview-edit')) return;\n    var preview = target.closest('.reward-preview'),\n      isCustom = preview.classList.contains('custom'),\n      previewThumb = !isCustom ? preview.querySelector('.reward-preview-thumb img').cloneNode() : '',\n      previewTitle = preview.querySelector('.reward-preview-title').innerText,\n      hiddenEdict = preview.querySelector('.reward-preview-edict').innerText,\n      hiddenNumber = preview.querySelector('.reward-preview-number').innerText,\n      hiddenDate = preview.querySelector('.reward-preview-date').innerText,\n      hiddenFor = preview.querySelector('.reward-preview-for').innerText,\n      hiddenPosthumously = preview.querySelector('.reward-preview-posthumously').innerText;\n\n    // Normal reward.\n    if (!isCustom) {\n      popupRewardThumb.innerHTML = '';\n      popupNoRewardThumb.classList.add('hidden');\n      popupRewardThumb.classList.remove('hidden');\n      popupRewardThumb.appendChild(previewThumb);\n    } else {\n      popupRewardThumb.classList.add('hidden');\n      popupNoRewardThumb.classList.remove('hidden');\n      rewardPopupCustomText.classList.remove('hidden');\n      customLabel.classList.remove('hidden');\n      customInput.value = previewTitle;\n    }\n    popupReward.setAttribute('data-id', preview.dataset.id);\n    popupRewardTitle.classList.remove('hidden');\n    popupRewardTitle.innerText = previewTitle;\n\n    // Pre-fill popup fields.\n    edictInput.value = hiddenEdict;\n    numberInput.value = hiddenNumber;\n    dateInput.value = hiddenDate;\n    forInput.value = hiddenFor;\n\n    // Pre-fill popup texts.\n    rewardPopupTextEdict.innerText = hiddenEdict;\n    rewardPopupTextNumber.innerText = \"\\u2116 \".concat(hiddenNumber);\n    rewardPopupTextDate.innerText = (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.formatDate)(hiddenDate);\n    rewardPopupTextFor.innerText = hiddenFor;\n    if (hiddenPosthumously) {\n      posthumously.checked = true;\n      rewardPopupTextPosthumously.classList.remove('hidden');\n    }\n    textAfterNumber.classList.remove('hidden');\n    textAfterDate.classList.remove('hidden');\n    hasRewardsBody.classList.add('hidden');\n    rewardsMainWrap.classList.remove('hidden');\n    popup.classList.remove('hidden');\n    window.scrollTo({\n      top: 0,\n      left: 0\n    });\n  });\n};\n\n/**\r\n * Clean reward popup form and texts.\r\n */\nvar cleanRewardPopup = function cleanRewardPopup() {\n  popup.classList.add('hidden');\n  rewardForm.reset();\n  customInput.innerText = '';\n  rewardPopupTextEdict.innerText = '';\n  rewardPopupTextNumber.innerText = '';\n  rewardPopupTextDate.innerText = '';\n  rewardPopupTextFor.innerText = '';\n  rewardPopupCustomText.classList.add('hidden');\n  customLabel.classList.add('hidden');\n  rewardPopupTextPosthumously.classList.add('hidden');\n  textAfterNumber.classList.add('hidden');\n  textAfterDate.classList.add('hidden');\n};\nvar checkStep3Military = function checkStep3Military() {\n  return true;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-3-military.js?");

/***/ }),

/***/ "./src/js/new-memory/step-3.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-3.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkEpitaphContentLength: function() { return /* binding */ checkEpitaphContentLength; },\n/* harmony export */   checkStep3: function() { return /* binding */ checkStep3; }\n/* harmony export */ });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n\nvar stepData = localStorage.getItem('ih-step-3') ? JSON.parse(localStorage.getItem('ih-step-3')) : {\n  'epitaph': '',\n  'epitaph-lastname': '',\n  'epitaph-firstname': '',\n  'epitaph-role': ''\n};\nvar textarea;\n\n/**\r\n * Listen to epitaph textarea changes.\r\n */\nvar checkEpitaphContentLength = function checkEpitaphContentLength() {\n  var fields = document.querySelectorAll('.epitaph input');\n  textarea = document.querySelector('.epitaph-text');\n  if (!textarea) return;\n  stepData.epitaph = textarea.value;\n  localStorage.setItem('ih-step-3', JSON.stringify(stepData));\n  textarea.addEventListener('keyup', onEpitaphChange);\n  textarea.addEventListener('change', onEpitaphChange);\n  textarea.addEventListener('focus', onEpitaphChange);\n  textarea.addEventListener('blur', onEpitaphChange);\n  if (!fields.length) return;\n  fields.forEach(function (field) {\n    field.addEventListener('change', function (e) {\n      return checkFieldValue(e);\n    });\n    field.addEventListener('keyup', function (e) {\n      return checkFieldValue(e);\n    });\n    field.addEventListener('blur', function (e) {\n      return checkFieldValue(e);\n    });\n  });\n  var checkFieldValue = function checkFieldValue(e) {\n    var field = e.target,\n      value = field.value,\n      index = field.name;\n    if (!value) field.classList.add('error');else field.classList.remove('error');\n    stepData[index] = value;\n    localStorage.setItem('ih-step-3', JSON.stringify(stepData));\n    (0,_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)(3);\n  };\n};\n\n/**\r\n * Check epitaph textarea length and compare with allowed length.\r\n */\nvar onEpitaphChange = function onEpitaphChange() {\n  // This is the first time textarea focused - clean it from the \"placeholder\" text.\n  if (textarea.classList.contains('clear-on-focus')) {\n    textarea.value = '';\n    textarea.classList.remove('clear-on-focus');\n  }\n  var value = textarea.value,\n    symbolsTyped = document.querySelector('.symbols-count-typed'),\n    symbolsAllowed = parseInt(document.querySelector('.symbols-count-allowed').innerText.trim());\n  if (!symbolsTyped || !symbolsAllowed) return;\n  stepData.epitaph = value;\n  localStorage.setItem('ih-step-3', JSON.stringify(stepData));\n  if (!value) {\n    (0,_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)(3);\n    symbolsTyped.innerHTML = 0;\n    return;\n  }\n\n  // Cut text if there are too many symbols.\n  if (value.length > symbolsAllowed) textarea.value = value.substring(0, symbolsAllowed);\n  symbolsTyped.innerHTML = textarea.value.length;\n  (0,_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)(3);\n};\n\n/**\r\n * Check if step 3 is ready.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep3 = function checkStep3() {\n  var epitaphValue = textarea.value,\n    fields = document.querySelectorAll('.epitaph input');\n  var isFormValid = true;\n  if (!epitaphValue || textarea.classList.contains('clear-on-focus')) return false;\n  if (fields.length) {\n    fields.forEach(function (field) {\n      var index = field.name,\n        value = field.value;\n      if (field.required && !value) isFormValid = false;\n      stepData[index] = value;\n    });\n  }\n  localStorage.setItem('ih-step-3', JSON.stringify(stepData));\n  return isFormValid;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-3.js?");

/***/ }),

/***/ "./src/js/new-memory/step-4.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-4.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkStep4: function() { return /* binding */ checkStep4; },\n/* harmony export */   externalLinkAdd: function() { return /* binding */ externalLinkAdd; },\n/* harmony export */   externalLinkDelete: function() { return /* binding */ externalLinkDelete; },\n/* harmony export */   externalLinksFieldsInput: function() { return /* binding */ externalLinksFieldsInput; },\n/* harmony export */   saveVideoPoster: function() { return /* binding */ saveVideoPoster; },\n/* harmony export */   selectScreenshot: function() { return /* binding */ selectScreenshot; },\n/* harmony export */   setDefaultDeletePhoto: function() { return /* binding */ setDefaultDeletePhoto; },\n/* harmony export */   setDefaultDeleteVideo: function() { return /* binding */ setDefaultDeleteVideo; },\n/* harmony export */   uploadCustomPoster: function() { return /* binding */ uploadCustomPoster; },\n/* harmony export */   uploadMediaPhotos: function() { return /* binding */ uploadMediaPhotos; },\n/* harmony export */   uploadMediaVideo: function() { return /* binding */ uploadMediaVideo; },\n/* harmony export */   uploadVideoLink: function() { return /* binding */ uploadVideoLink; },\n/* harmony export */   videoLinkInput: function() { return /* binding */ videoLinkInput; }\n/* harmony export */ });\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\nvar stepData = localStorage.getItem('ih-step-4') ? JSON.parse(localStorage.getItem('ih-step-4')) : {\n  photos: [],\n  videos: [],\n  links: [{\n    url: '',\n    title: '',\n    position: 0\n  }]\n};\nvar videoDuration = 0;\n\n/**\r\n * Upload media photos.\r\n */\nvar uploadMediaPhotos = function uploadMediaPhotos() {\n  var droparea = document.querySelector('.droparea-photo'),\n    inputs = document.querySelectorAll('.file-photo');\n  var fileInstance;\n  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(function (event) {\n    document.addEventListener(event, function (evt) {\n      return evt.preventDefault();\n    });\n  });\n  ['dragenter', 'dragover'].forEach(function (event) {\n    droparea.addEventListener(event, function () {\n      return droparea.classList.add('dragover');\n    });\n  });\n  ['dragleave', 'drop'].forEach(function (event) {\n    droparea.addEventListener(event, function () {\n      return droparea.classList.remove('dragover');\n    });\n  });\n  var handlePhotosUpload = function handlePhotosUpload(e) {\n    fileInstance = e.target.tagName === 'INPUT' ? _toConsumableArray(e.target.files) : _toConsumableArray(e.dataTransfer.files);\n    if (!fileInstance.length) return;\n\n    // Loop through all files.\n    for (var i = 0; i < fileInstance.length; i++) {\n      if (fileInstance[i].size > 50 * _common_global__WEBPACK_IMPORTED_MODULE_0__.BYTES_IN_MB) {\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u041D\\u0435 \\u0432\\u0434\\u0430\\u043B\\u043E\\u0441\\u044F \\u0437\\u0430\\u0432\\u0430\\u043D\\u0442\\u0430\\u0436\\u0438\\u0442\\u0438 \\u0444\\u043E\\u0442\\u043E \".concat(fileInstance[i].name), 'error');\n        return false;\n      }\n      if (fileInstance[i].type.startsWith('image/')) processingUploadMediaPhoto(fileInstance[i], i, droparea, fileInstance.length);else (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u0422\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F - \\u0444\\u0430\\u0439\\u043B \".concat(fileInstance[i].name, \" \\u043D\\u0435 \\u0454 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F\\u043C\"), 'warning');\n    }\n  };\n  droparea.addEventListener('drop', handlePhotosUpload);\n  inputs.forEach(function (input) {\n    return input.addEventListener('change', handlePhotosUpload);\n  });\n};\n\n/**\r\n * Processing photos uploading.\r\n *\r\n * @param file\r\n * @param index\r\n * @param droparea\r\n */\nvar processingUploadMediaPhoto = function processingUploadMediaPhoto(file, index, droparea, count) {\n  if (!file || !droparea) return;\n  var loader = droparea.querySelector('.droparea-loader'),\n    percentsValue = loader.querySelector('.droparea-loader-percents span'),\n    progress = loader.querySelector('progress'),\n    cancel = loader.querySelector('.droparea-loader-cancel'),\n    inner = droparea.querySelector('.droparea-inner'),\n    imagesWrapper = droparea.querySelector('.droparea-images'),\n    dropareaData = new FormData(),\n    xhr = new XMLHttpRequest();\n  dropareaData.append('file', file);\n  dropareaData.append('action', 'ih_ajax_upload_memory_photo');\n  xhr.upload.addEventListener('progress', function (e) {\n    var bytesLoaded = e.loaded,\n      bytesTotal = e.total,\n      percent = parseInt(bytesLoaded / bytesTotal * 100);\n    inner.classList.add('hidden');\n    loader.classList.remove('hidden');\n    percentsValue.innerHTML = percent;\n    progress.value = percent;\n  });\n  cancel.addEventListener('click', function () {\n    xhr.abort();\n    progress.value = 0;\n    setTimeout(function () {\n      loader.classList.add('hidden');\n\n      // No images - just show inner.\n      if (!document.querySelectorAll('.droparea-img-loaded:not(.droparea-video-loaded)').length) inner.classList.remove('hidden');\n    }, 500);\n  });\n  xhr.open('POST', _common_global__WEBPACK_IMPORTED_MODULE_0__.ajaxUrl, true);\n  xhr.send(dropareaData);\n  xhr.onload = function () {\n    if (xhr.status == 200) {\n      var response = JSON.parse(xhr.response),\n        data = response.data;\n      var imageHTML = '';\n      if (data.success == 1) {\n        imageHTML = getPhotoHTML(data, file.name);\n        imagesWrapper.querySelector('.droparea-images-load').insertAdjacentHTML('beforebegin', imageHTML);\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(data.msg);\n        imagesWrapper.querySelector(\".droparea-img-delete[data-id=\\\"\".concat(data.attachId, \"\\\"]\")).addEventListener('click', function (e) {\n          return (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showAreYouSurePopup)(e.target, cancelCBb, function () {\n            return applyCBb(e, droparea);\n          });\n        });\n        (0,_common__WEBPACK_IMPORTED_MODULE_1__.isStepFilled)(4);\n        stepData.photos.push(data.attachId);\n        localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n\n        // Show images wrapper if the last images was loaded.\n        if (index === count - 1) {\n          setTimeout(function () {\n            loader.classList.add('hidden');\n            imagesWrapper.classList.remove('hidden');\n          }, 2000);\n        }\n      }\n    } else {\n      // If no images loaded yet.\n      if (!document.querySelectorAll('.droparea-img-loaded:not(.droparea-video-loaded)').length) inner.classList.remove('hidden');else imagesWrapper.classList.remove('hidden');\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u041F\\u043E\\u043C\\u0438\\u043B\\u043A\\u0430 \".concat(xhr.status, \". \\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0456\\u0442\\u044C \\u0441\\u043F\\u0440\\u043E\\u0431\\u0443 \\u043F\\u0456\\u0437\\u043D\\u0456\\u0448\\u0435.\"), 'warning');\n    }\n  };\n};\n\n/**\r\n * Get photo item HTML layout.\r\n *\r\n * @param {object}\tdata\t\tPhoto data object from the backend.\r\n * @param {string}\tfilename\tPhoto file name.\r\n * @returns {string}\t\t\tPhoto item HTML layout.\r\n */\nvar getPhotoHTML = function getPhotoHTML(data, filename) {\n  var maskId = \"mask0_\".concat(Math.random() * 10000, \"_\").concat(Math.random() * 10000);\n  return \"<div class=\\\"droparea-img-loaded\\\">\\n\\t\\t<img src=\\\"\".concat(data.url, \"\\\" alt=\\\"\").concat(filename, \"\\\" />\\n\\t\\t<div class=\\\"droparea-img-delete flex align-center justify-center\\\" data-id=\\\"\").concat(data.attachId, \"\\\">\\n\\t\\t\\t<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t\\t\\t<mask id=\\\"\").concat(maskId, \"\\\" style=\\\"mask-type:alpha\\\" maskUnits=\\\"userSpaceOnUse\\\" x=\\\"5\\\" y=\\\"3\\\" width=\\\"14\\\" height=\\\"18\\\">\\n\\t\\t\\t\\t\\t<path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M14.79 3.29L15.5 4H18C18.55 4 19 4.45 19 5C19 5.55 18.55 6 18 6H6C5.45 6 5 5.55 5 5C5 4.45 5.45 4 6 4H8.5L9.21 3.29C9.39 3.11 9.65 3 9.91 3H14.09C14.35 3 14.61 3.11 14.79 3.29ZM6 19C6 20.1 6.9 21 8 21H16C17.1 21 18 20.1 18 19V9C18 7.9 17.1 7 16 7H8C6.9 7 6 7.9 6 9V19ZM9 9H15C15.55 9 16 9.45 16 10V18C16 18.55 15.55 19 15 19H9C8.45 19 8 18.55 8 18V10C8 9.45 8.45 9 9 9Z\\\" fill=\\\"black\\\"/>\\n\\t\\t\\t\\t</mask>\\n\\t\\t\\t\\t<g mask=\\\"url(#\").concat(maskId, \")\\\">\\n\\t\\t\\t\\t\\t<rect width=\\\"24\\\" height=\\\"24\\\" fill=\\\"currentColor\\\"/>\\n\\t\\t\\t\\t</g>\\n\\t\\t\\t</svg>\\n\\t\\t</div>\\n\\t</div>\");\n};\n\n/**\r\n * Cancel are you sure popup.\r\n *\r\n * @param {Event} e\r\n */\nvar cancelCBb = function cancelCBb(e) {\n  e.stopPropagation();\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideAreYouSurePopup)();\n};\n\n/**\r\n * Apply are you sure popup.\r\n *\r\n * @param {Event} e\r\n * @param {HTMLObjectElement} droparea\r\n */\nvar applyCBb = function applyCBb(e, droparea) {\n  if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n  var inner = droparea.querySelector('.droparea-inner'),\n    imagesWrapper = droparea.querySelector('.droparea-images'),\n    id = e.target.closest('.droparea-img-delete').dataset.id,\n    formData = new FormData();\n  formData.append('action', 'ih_ajax_delete_memory_photo');\n  formData.append('id', id);\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n    if (res) {\n      switch (res.success) {\n        case true:\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg);\n          e.target.closest('.droparea-img-loaded').remove();\n\n          // If there are no more images loaded.\n          if (!imagesWrapper.querySelectorAll('.droparea-img-loaded:not(.droparea-video-loaded)').length) {\n            imagesWrapper.classList.add('hidden');\n            inner.classList.remove('hidden');\n          }\n          (0,_common__WEBPACK_IMPORTED_MODULE_1__.isStepFilled)(4);\n          stepData.photos.forEach(function (photoId, i) {\n            if (photoId == id) stepData.photos.splice(i, 1);\n          });\n          localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n          break;\n        case false:\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n          break;\n      }\n    }\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideAreYouSurePopup)();\n  });\n};\n\n/**\r\n * Set click listener by default to photo delete buttons.\r\n */\nvar setDefaultDeletePhoto = function setDefaultDeletePhoto() {\n  var droparea = document.querySelector('.droparea-photo'),\n    buttons = droparea.querySelectorAll('.droparea-img-delete');\n  if (!buttons.length) return;\n  buttons.forEach(function (btn) {\n    btn.addEventListener('click', function (e) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showAreYouSurePopup)(e.target, cancelCBb, function () {\n        return applyCBb(e, droparea);\n      });\n    });\n  });\n};\n\n/**\r\n * Set click listener by default to video delete buttons.\r\n */\nvar setDefaultDeleteVideo = function setDefaultDeleteVideo() {\n  var droparea = document.querySelector('.droparea-video'),\n    buttons = droparea.querySelectorAll('.droparea-img-delete');\n  if (!buttons.length) return;\n  buttons.forEach(function (btn) {\n    btn.addEventListener('click', function (e) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showAreYouSurePopup)(e.target, cancelCBb, function () {\n        return applyVideoCb(e);\n      });\n    });\n  });\n};\n\n/**\r\n * Upload media video.\r\n */\nvar uploadMediaVideo = function uploadMediaVideo() {\n  var droparea = document.querySelector('.droparea-video'),\n    inputs = document.querySelectorAll('.file-video');\n  var fileInstance;\n  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(function (event) {\n    document.addEventListener(event, function (evt) {\n      return evt.preventDefault();\n    });\n  });\n  ['dragenter', 'dragover'].forEach(function (event) {\n    droparea.addEventListener(event, function () {\n      return droparea.classList.add('dragover');\n    });\n  });\n  ['dragleave', 'drop'].forEach(function (event) {\n    droparea.addEventListener(event, function () {\n      return droparea.classList.remove('dragover');\n    });\n  });\n  var handleVideoUpload = function handleVideoUpload(e) {\n    fileInstance = e.target.tagName === 'INPUT' ? _toConsumableArray(e.target.files) : _toConsumableArray(e.dataTransfer.files);\n    if (!fileInstance.length || (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n\n    // Create video element to check duration.\n    var video = document.createElement('video');\n    video.src = URL.createObjectURL(fileInstance[0]);\n    video.ondurationchange = function () {\n      return videoDuration = getPrettyVideoDuration(video.duration);\n    };\n    if (fileInstance[0].size > 1024 * _common_global__WEBPACK_IMPORTED_MODULE_0__.BYTES_IN_MB) {\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Не більше 1 гб', 'error');\n      return false;\n    }\n    if (fileInstance[0].type.startsWith('video/')) processingUploadMediaVideo(fileInstance[0], droparea);else (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u0422\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0432\\u0456\\u0434\\u0435\\u043E\\u0444\\u0430\\u0439\\u043B\\u0438 - \\u0444\\u0430\\u0439\\u043B \".concat(fileInstance[0].name, \" \\u043D\\u0435 \\u0432\\u0456\\u0434\\u0435\\u043E\"), 'error');\n  };\n  droparea.addEventListener('drop', handleVideoUpload);\n  inputs.forEach(function (input) {\n    return input.addEventListener('change', handleVideoUpload);\n  });\n};\n\n/**\r\n * Pretty video duration output string.\r\n *\r\n * @param durationInSeconds\r\n * @returns {string}\r\n */\nvar getPrettyVideoDuration = function getPrettyVideoDuration(durationInSeconds) {\n  durationInSeconds = Math.floor(durationInSeconds);\n  if (!durationInSeconds || durationInSeconds < 1) return;\n  if (durationInSeconds < 60) return \"00:00:\".concat(durationInSeconds);\n  var hours = Math.floor(durationInSeconds / (60 * 60)),\n    minutes = Math.floor(durationInSeconds / 60 % 60),\n    seconds = Math.floor(durationInSeconds % 60);\n  hours = hours < 10 ? \"0\".concat(hours) : hours;\n  minutes = minutes < 10 ? \"0\".concat(minutes) : minutes;\n  seconds = seconds < 10 ? \"0\".concat(seconds) : seconds;\n  return \"\".concat(hours, \":\").concat(minutes, \":\").concat(seconds);\n};\n\n/**\r\n * Processing photos uploading.\r\n *\r\n * @param file\r\n * @param droparea\r\n */\nvar processingUploadMediaVideo = function processingUploadMediaVideo(file, droparea) {\n  if (!file || !droparea) return;\n  var loader = droparea.querySelector('.droparea-loader'),\n    percentsValue = loader.querySelector('.droparea-loader-percents span'),\n    progress = loader.querySelector('progress'),\n    cancel = loader.querySelector('.droparea-loader-cancel'),\n    inner = droparea.querySelector('.droparea-inner'),\n    videosWrapper = droparea.querySelector('.droparea-videos'),\n    thumbsWrapper = droparea.querySelector('.droparea-thumbs'),\n    dropareaData = new FormData(),\n    xhr = new XMLHttpRequest();\n  dropareaData.append('file', file);\n  dropareaData.append('action', 'ih_ajax_upload_memory_video');\n  xhr.upload.addEventListener('progress', function (e) {\n    var bytesLoaded = e.loaded,\n      bytesTotal = e.total,\n      percent = parseInt(bytesLoaded / bytesTotal * 100);\n    inner.classList.add('hidden');\n    loader.classList.remove('hidden');\n    percentsValue.innerHTML = percent;\n    progress.value = percent;\n  });\n  cancel.addEventListener('click', function () {\n    xhr.abort();\n    progress.value = 0;\n    setTimeout(function () {\n      inner.classList.remove('hidden');\n      loader.classList.add('hidden');\n    }, 500);\n  });\n  xhr.open('POST', _common_global__WEBPACK_IMPORTED_MODULE_0__.ajaxUrl, true);\n  xhr.send(dropareaData);\n  xhr.onload = function () {\n    loader.classList.add('hidden');\n    if (xhr.status == 200) {\n      var response = JSON.parse(xhr.response),\n        data = response.data;\n      if (data.success == 1) {\n        // If there are already loaded videos.\n        if (document.querySelectorAll('.droparea-video-loaded').length) {\n          var thumbsWrapperCloned = thumbsWrapper.cloneNode(true);\n          document.querySelector('.droparea-videos-load').append(thumbsWrapperCloned);\n          uploadCustomPoster();\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideElement)(document.querySelector('.droparea-videos-load-inner'));\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showElement)(thumbsWrapperCloned);\n          thumbsWrapper.remove();\n          showScreenshots(thumbsWrapperCloned.querySelector('.droparea-thumbs-list'), data.shots);\n        } else {\n          thumbsWrapper.classList.remove('hidden');\n          showScreenshots(thumbsWrapper.querySelector('.droparea-thumbs-list'), data.shots);\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u0424\\u0430\\u0439\\u043B \".concat(file.name, \" \\u0443\\u0441\\u043F\\u0456\\u0448\\u043D\\u043E \\u0437\\u0430\\u0432\\u0430\\u043D\\u0442\\u0430\\u0436\\u0435\\u043D\\u043E\"));\n      }\n    } else {\n      // If no videos loaded yet.\n      if (!document.querySelectorAll('.droparea-video-loaded').length) inner.classList.remove('hidden');else videosWrapper.classList.remove('hidden');\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u041F\\u043E\\u043C\\u0438\\u043B\\u043A\\u0430 \".concat(xhr.status, \". \\u041F\\u043E\\u0432\\u0442\\u043E\\u0440\\u0456\\u0442\\u044C \\u0441\\u043F\\u0440\\u043E\\u0431\\u0443 \\u043F\\u0456\\u0437\\u043D\\u0456\\u0448\\u0435.\"), 'warning');\n    }\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n  };\n};\n\n/**\r\n * Upload video links.\r\n */\nvar videoLinkInput = function videoLinkInput() {\n  var inputs = document.querySelectorAll('input[name=\"video-link\"]');\n  if (!inputs.length) return;\n  inputs.forEach(function (input) {\n    input.addEventListener('change', onVideoLinkInput);\n    input.addEventListener('keyup', onVideoLinkInput);\n    input.addEventListener('blur', onVideoLinkInput);\n  });\n};\n\n/**\r\n * Video link input change handler.\r\n *\r\n * @param {Event} e\r\n */\nvar onVideoLinkInput = function onVideoLinkInput(e) {\n  var target = e.target,\n    value = target.value,\n    button = target.closest('.video-link-row').querySelector('.video-link-upload');\n  if (value) button.disabled = false;else button.disabled = true;\n};\n\n/**\r\n * Upload video link.\r\n */\nvar uploadVideoLink = function uploadVideoLink() {\n  var buttons = document.querySelectorAll('.video-link-upload');\n  if (!buttons.length) return;\n  buttons.forEach(function (btn) {\n    btn.addEventListener('click', function (e) {\n      if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n      var input = e.target.closest('.video-link-row').querySelector('input'),\n        link = input.value,\n        formData = new FormData();\n      if (!link) return;\n      formData.append('action', 'ih_ajax_upload_video_link');\n      formData.append('link', link);\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n        if (res) {\n          switch (res.success) {\n            case true:\n              input.value = '';\n              btn.disabled = true;\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg);\n              break;\n            case false:\n              (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n              break;\n          }\n        }\n        (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n      });\n    });\n  });\n};\n\n/**\r\n * Return shorter filename.\r\n *\r\n * @param {string} filename\r\n * @returns {string}\r\n */\nvar getFilename = function getFilename(filename) {\n  var extension = /(?:\\.([^.]+))?$/.exec(filename)[1];\n  filename = filename.replace(/[_\\-]/g, ' ');\n  return filename.substring(0, filename.length - extension.length - 1);\n};\n\n/**\r\n * Show screenshots from the uploaded video.\r\n *\r\n * @param {HTMLObjectElement}\tcontainer\tWhere to append screenshots.\r\n * @param {string}\t\t\t\tshots\t\tJSON string from the server with the screenshots' data.\r\n */\nvar showScreenshots = function showScreenshots(container, shots) {\n  shots = JSON.parse(shots);\n  if (!container || !shots.length) return;\n  shots.forEach(function (shot) {\n    var shotHTML = \"<div class=\\\"droparea-thumb\\\">\\n\\t\\t\\t<img class=\\\"droparea-thumb-img\\\" src=\\\"\".concat(shot, \"\\\" alt=\\\"\\\" />\\n\\t\\t</div>\");\n    container.insertAdjacentHTML('beforeend', shotHTML);\n  });\n};\n\n/**\r\n * Make selected screenshot active.\r\n */\nvar selectScreenshot = function selectScreenshot() {\n  var shotsList = document.querySelector('.droparea-video');\n  if (!shotsList) return;\n  shotsList.addEventListener('click', function (e) {\n    var target = e.target,\n      prevActive = document.querySelector('.droparea-thumb.active');\n    if (!target.closest('.droparea-thumb')) return;\n    if (prevActive) prevActive.classList.remove('active');\n    target.closest('.droparea-thumb').classList.add('active');\n  });\n};\n\n/**\r\n * Save selected video poster.\r\n */\nvar saveVideoPoster = function saveVideoPoster() {\n  var area = document.querySelector('.droparea-video');\n  if (!area) return;\n  area.addEventListener('click', function (e) {\n    var target = e.target,\n      activeShot = document.querySelector('.droparea-thumb.active');\n    if (!activeShot || (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)() || !target.className || !target.classList.contains('droparea-thumbs-save')) return;\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n    var src = activeShot.querySelector('.droparea-thumb-img').src,\n      formData = new FormData();\n    formData.append('action', 'ih_ajax_set_poster');\n    formData.append('src', src);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n      if (res) {\n        switch (res.success) {\n          case true:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg);\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideElement)(document.querySelector('.droparea-thumbs'));\n            clearThumbsList();\n            outputVideoWithPoster(res.data, src);\n            if (document.querySelectorAll('.droparea-video-loaded').length > 1) (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showElement)(document.querySelector('.droparea-videos-load-inner'));else (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showElement)(document.querySelector('.droparea-videos'));\n            break;\n          case false:\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n            break;\n        }\n      }\n      (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    });\n  });\n};\n\n/**\r\n * Remove all video thumbs (posters).\r\n */\nvar clearThumbsList = function clearThumbsList() {\n  var thumbs = document.querySelectorAll('.droparea-thumb');\n  if (!thumbs.length) return;\n  thumbs.forEach(function (thumb) {\n    return thumb.remove();\n  });\n};\n\n/**\r\n * Get video item HTML layout.\r\n *\r\n * @param {object}\tvideoData\tVideo data object.\r\n * @param {string}\tposter\t\tVideo poster URL.\r\n * @returns {string}\t\t\tVideo item HTML layout.\r\n */\nvar getVideoHTML = function getVideoHTML(videoData, poster) {\n  var maskId = \"mask0_\".concat(Math.random() * 10000, \"_\").concat(Math.random() * 10000);\n  return \"<div class=\\\"droparea-img-loaded droparea-video-loaded\\\">\\n\\t\\t<div class=\\\"droparea-video-wrapper\\\">\\n\\t\\t\\t<video src=\\\"\".concat(videoData.url, \"\\\" poster=\\\"\").concat(poster, \"\\\"></video>\\n\\t\\t\\t<div\\n\\t\\t\\t\\tclass=\\\"droparea-img-delete flex align-center justify-center\\\"\\n\\t\\t\\t\\tdata-id=\\\"\").concat(videoData.attachId, \"\\\"\\n\\t\\t\\t\\tdata-is-video=\\\"1\\\"\\n\\t\\t\\t>\\n\\t\\t\\t\\t<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t\\t\\t\\t<mask id=\\\"\").concat(maskId, \"\\\" style=\\\"mask-type:alpha\\\" maskUnits=\\\"userSpaceOnUse\\\" x=\\\"5\\\" y=\\\"3\\\" width=\\\"14\\\" height=\\\"18\\\">\\n\\t\\t\\t\\t\\t\\t<path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M14.79 3.29L15.5 4H18C18.55 4 19 4.45 19 5C19 5.55 18.55 6 18 6H6C5.45 6 5 5.55 5 5C5 4.45 5.45 4 6 4H8.5L9.21 3.29C9.39 3.11 9.65 3 9.91 3H14.09C14.35 3 14.61 3.11 14.79 3.29ZM6 19C6 20.1 6.9 21 8 21H16C17.1 21 18 20.1 18 19V9C18 7.9 17.1 7 16 7H8C6.9 7 6 7.9 6 9V19ZM9 9H15C15.55 9 16 9.45 16 10V18C16 18.55 15.55 19 15 19H9C8.45 19 8 18.55 8 18V10C8 9.45 8.45 9 9 9Z\\\" fill=\\\"black\\\"/>\\n\\t\\t\\t\\t\\t</mask>\\n\\t\\t\\t\\t\\t<g mask=\\\"url(#\").concat(maskId, \")\\\">\\n\\t\\t\\t\\t\\t\\t<rect width=\\\"24\\\" height=\\\"24\\\" fill=\\\"currentColor\\\"/>\\n\\t\\t\\t\\t\\t</g>\\n\\t\\t\\t\\t</svg>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"droparea-video-title\\\">\").concat(getFilename(videoData.filename), \"</div>\\n\\t\\t<div class=\\\"droparea-video-duration\\\">\").concat(videoDuration, \"</div>\\n\\t</div>\");\n};\n\n/**\r\n * Output HTML5 video after poster is set.\r\n *\r\n * @param {object} videoData\r\n * @param {string} poster\r\n */\nvar outputVideoWithPoster = function outputVideoWithPoster(videoData, poster) {\n  var videosWrapper = document.querySelector('.droparea-videos'),\n    videoHTML = getVideoHTML(videoData, poster);\n  videosWrapper.querySelector('.droparea-videos-load').insertAdjacentHTML('beforebegin', videoHTML);\n  videosWrapper.querySelector(\".droparea-img-delete[data-id=\\\"\".concat(videoData.attachId, \"\\\"]\")).addEventListener('click', function (e) {\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showAreYouSurePopup)(e.target, cancelCBb, function () {\n      return applyVideoCb(e);\n    }, 'Дійсно видалити відео?');\n  });\n  stepData.videos.push({\n    id: videoData.attachId,\n    poster: videoData.posterId\n  });\n  localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n};\n\n/**\r\n * Delete video.\r\n *\r\n * @param {Event} e\r\n */\nvar applyVideoCb = function applyVideoCb(e) {\n  if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n  var id = e.target.closest('.droparea-img-delete').dataset.id,\n    isVideo = e.target.closest('.droparea-img-delete').dataset.isVideo,\n    formData = new FormData(),\n    videosWrapper = document.querySelector('.droparea-videos');\n  formData.append('action', 'ih_ajax_delete_memory_photo');\n  formData.append('id', id);\n  formData.append('video', isVideo);\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(formData).then(function (res) {\n    if (res) {\n      switch (res.success) {\n        case true:\n          e.target.closest('.droparea-video-loaded').remove();\n\n          // If there are no more video loaded.\n          if (!videosWrapper.querySelectorAll('.droparea-video-loaded').length) {\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideElement)(videosWrapper);\n            (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showElement)(document.querySelector('.droparea-video .droparea-inner'));\n            var thumbsWrapper = document.querySelector('.droparea-thumbs'),\n              thumbsWrapperCloned = thumbsWrapper.cloneNode(true);\n            document.querySelector('.droparea-video').append(thumbsWrapperCloned);\n            uploadCustomPoster();\n            thumbsWrapper.remove();\n          }\n          stepData.videos.forEach(function (video, i) {\n            if (video.id == id) stepData.videos.splice(i, 1);\n          });\n          localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n          break;\n        case false:\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n          break;\n      }\n    }\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.hideAreYouSurePopup)();\n  });\n};\n\n/**\r\n * Upload custom poster from device.\r\n */\nvar uploadCustomPoster = function uploadCustomPoster() {\n  var input = document.querySelector('.file-load-poster');\n  if (!input) return;\n  input.removeEventListener('change', onCustomPosterInputChange);\n  input.addEventListener('change', onCustomPosterInputChange);\n};\n\n/**\r\n * Upload custom poster input change handler.\r\n *\r\n * @param {Event} e\r\n * @returns {boolean}\r\n */\nvar onCustomPosterInputChange = function onCustomPosterInputChange(e) {\n  var fileInstance = _toConsumableArray(e.target.files),\n    loadArea = document.querySelector('.droparea-thumbs-list');\n  if (!fileInstance.length) return;\n  var file = fileInstance[0];\n  if (file.size > 5 * _common_global__WEBPACK_IMPORTED_MODULE_0__.BYTES_IN_MB) {\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Розмір повинен бути меньше 5 мб', 'error');\n    return false;\n  }\n  if (file.type.startsWith('image/')) processingUploadCustomPoster(file, loadArea);else (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u0422\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F - \\u0444\\u0430\\u0439\\u043B \".concat(file.name, \" \\u043D\\u0435 \\u0454 \\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u043D\\u044F\\u043C\"), 'error');\n};\n\n/**\r\n * Upload custom poster handler.\r\n *\r\n * @param file\r\n * @param droparea\r\n */\nvar processingUploadCustomPoster = function processingUploadCustomPoster(file, droparea) {\n  if (!file || !droparea) return;\n  var dropareaData = new FormData();\n  if ((0,_common_global__WEBPACK_IMPORTED_MODULE_0__.checkAjaxWorkingStatus)()) return;\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(true);\n  dropareaData.append('action', 'ih_ajax_upload_custom_poster');\n  dropareaData.append('file', file);\n  (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.ihAjaxRequest)(dropareaData).then(function (res) {\n    if (res) {\n      switch (res.success) {\n        case true:\n          var imageHTML = \"<div class=\\\"droparea-thumb\\\">\\n\\t\\t\\t\\t\\t\\t<img class=\\\"droparea-thumb-img\\\" src=\\\"\".concat(res.data.url, \"\\\" alt=\\\"\").concat(file.name, \"\\\" />\\n\\t\\t\\t\\t\\t</div>\");\n          droparea.insertAdjacentHTML('beforeend', imageHTML);\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\"\\u041E\\u0431\\u043A\\u043B\\u0430\\u0434\\u0438\\u043D\\u043A\\u0430 \".concat(file.name, \" \\u0443\\u0441\\u043F\\u0456\\u0448\\u043D\\u043E \\u0437\\u0430\\u0432\\u0430\\u043D\\u0442\\u0430\\u0436\\u0435\\u043D\\u043E\"));\n          break;\n        case false:\n          (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.showNotification)(res.data.msg, 'error');\n          break;\n      }\n    }\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_0__.setAjaxWorkingStatus)(false);\n  });\n};\n\n/**\r\n * Listen to external links fields.\r\n */\nvar externalLinksFieldsInput = function externalLinksFieldsInput() {\n  var fields = document.querySelectorAll('.step-media-link');\n  if (!fields.length) return;\n  fields.forEach(function (field) {\n    var urlField = field.querySelector('input[id^=\"media-link-\"]'),\n      urlTitle = field.querySelector('input[id^=\"media-name-link-\"]');\n    if (!urlField || !urlTitle) return;\n    urlField.removeEventListener('keyup', onExternalLinkFieldInput);\n    urlField.removeEventListener('change', onExternalLinkFieldInput);\n    urlField.removeEventListener('blur', onExternalLinkFieldInput);\n    urlField.addEventListener('change', onExternalLinkFieldInput);\n    urlField.addEventListener('keyup', onExternalLinkFieldInput);\n    urlField.addEventListener('blur', onExternalLinkFieldInput);\n    urlTitle.removeEventListener('keyup', onExternalLinkFieldInput);\n    urlTitle.removeEventListener('change', onExternalLinkFieldInput);\n    urlTitle.removeEventListener('blur', onExternalLinkFieldInput);\n    urlTitle.addEventListener('change', onExternalLinkFieldInput);\n    urlTitle.addEventListener('keyup', onExternalLinkFieldInput);\n    urlTitle.addEventListener('blur', onExternalLinkFieldInput);\n  });\n};\n\n/**\r\n * Handle external links input.\r\n *\r\n * @param {Event} e\r\n */\nvar onExternalLinkFieldInput = function onExternalLinkFieldInput(e) {\n  var target = e.target,\n    value = target.value,\n    label = target.closest('label'),\n    link = target.closest('.step-media-link'),\n    index = link.dataset.id,\n    type = target.dataset.type === 'url' ? 'url' : 'title',\n    secondField = type === 'url' ? link.querySelector('input[data-type=\"title\"]') : link.querySelector('input[data-type=\"url\"]'),\n    addLinkBtn = document.querySelector('.media-links-add');\n  if (!value) label.classList.add('error');else label.classList.remove('error');\n\n  // Both fields are set - show buttons.\n  if (value && secondField.value) {\n    link.classList.add('filled');\n    addLinkBtn.classList.remove('hidden');\n  } else {\n    if (document.querySelectorAll('.step-media-link').length === 1) {\n      link.classList.remove('filled');\n      addLinkBtn.classList.add('hidden');\n    }\n  }\n  stepData.links[index][type] = value;\n  localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n};\n\n/**\r\n * Get External link HTML structure.\r\n *\r\n * @param index\r\n */\nvar getExternalLinkHTML = function getExternalLinkHTML() {\n  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var linkClass = index ? ' filled' : '';\n  return \"<div class=\\\"step-media-link flex flex-wrap\".concat(linkClass, \"\\\" data-id=\\\"\").concat(index, \"\\\">\\n\\t\\t\\t<label for=\\\"media-link-\").concat(index, \"\\\" class=\\\"label half\\\">\\n\\t\\t\\t\\t<span class=\\\"label-text\\\">\\u041F\\u043E\\u0441\\u0438\\u043B\\u0430\\u043D\\u043D\\u044F</span>\\n\\t\\t\\t\\t<input\\n\\t\\t\\t\\t\\tid=\\\"media-link-\").concat(index, \"\\\"\\n\\t\\t\\t\\t\\tname=\\\"media-link-\").concat(index, \"\\\"\\n\\t\\t\\t\\t\\ttype=\\\"text\\\"\\n\\t\\t\\t\\t\\tdata-type=\\\"url\\\"\\n\\t\\t\\t\\t\\tplaceholder=\\\"\\u0414\\u043E\\u0434\\u0430\\u0442\\u0438 \\u043F\\u043E\\u0441\\u0438\\u043B\\u0430\\u043D\\u043D\\u044F\\\"\\n\\t\\t\\t\\t\\trequired\\n\\t\\t\\t\\t/>\\n\\t\\t\\t</label>\\n\\t\\t\\t<label for=\\\"media-name-link-\").concat(index, \"\\\" class=\\\"label half end\\\">\\n\\t\\t\\t\\t<span class=\\\"label-text\\\">\\u041D\\u0430\\u0437\\u0432\\u0430 \\u043F\\u043E\\u0441\\u0438\\u043B\\u0430\\u043D\\u043D\\u044F</span>\\n\\t\\t\\t\\t<input\\n\\t\\t\\t\\t\\tid=\\\"media-name-link-\").concat(index, \"\\\"\\n\\t\\t\\t\\t\\tname=\\\"media-name-link-\").concat(index, \"\\\"\\n\\t\\t\\t\\t\\ttype=\\\"text\\\"\\n\\t\\t\\t\\t\\tdata-type=\\\"title\\\"\\n\\t\\t\\t\\t\\tplaceholder=\\\"\\u0414\\u043E\\u0434\\u0430\\u0442\\u0438 \\u043F\\u043E\\u0441\\u0438\\u043B\\u0430\\u043D\\u043D\\u044F\\\"\\n\\t\\t\\t\\t\\trequired\\n\\t\\t\\t\\t/>\\n\\t\\t\\t</label>\\n\\t\\t\\t<button class=\\\"media-link-delete\\\" title=\\\"\\u0412\\u0438\\u0434\\u0430\\u043B\\u0438\\u0442\\u0438 \\u043F\\u043E\\u0441\\u0438\\u043B\\u0430\\u043D\\u043D\\u044F\\\" type=\\\"button\\\">\\n\\t\\t\\t\\t<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t\\t\\t\\t<mask id=\\\"mask_link_\").concat(index, \"\\\" style=\\\"mask-type:alpha\\\" maskUnits=\\\"userSpaceOnUse\\\" x=\\\"5\\\" y=\\\"3\\\" width=\\\"14\\\" height=\\\"18\\\">\\n\\t\\t\\t\\t\\t\\t<path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M14.79 3.29L15.5 4H18C18.55 4 19 4.45 19 5C19 5.55 18.55 6 18 6H6C5.45 6 5 5.55 5 5C5 4.45 5.45 4 6 4H8.5L9.21 3.29C9.39 3.11 9.65 3 9.91 3H14.09C14.35 3 14.61 3.11 14.79 3.29ZM6 19C6 20.1 6.9 21 8 21H16C17.1 21 18 20.1 18 19V9C18 7.9 17.1 7 16 7H8C6.9 7 6 7.9 6 9V19ZM9 9H15C15.55 9 16 9.45 16 10V18C16 18.55 15.55 19 15 19H9C8.45 19 8 18.55 8 18V10C8 9.45 8.45 9 9 9Z\\\" fill=\\\"black\\\"/>\\n\\t\\t\\t\\t\\t</mask>\\n\\t\\t\\t\\t\\t<g mask=\\\"url(#mask_link_\").concat(index, \")\\\">\\n\\t\\t\\t\\t\\t\\t<rect width=\\\"24\\\" height=\\\"24\\\" fill=\\\"currentColor\\\"/>\\n\\t\\t\\t\\t\\t</g>\\n\\t\\t\\t\\t</svg>\\n\\t\\t\\t</button>\\n\\t\\t</div>\");\n};\n\n/**\r\n * Add external link.\r\n */\nvar externalLinkAdd = function externalLinkAdd() {\n  var button = document.querySelector('.media-links-add');\n  if (!button) return;\n  button.addEventListener('click', function () {\n    var id = document.querySelectorAll('.step-media-link').length;\n    document.querySelector('.step-media-links').insertAdjacentHTML('beforeend', getExternalLinkHTML(id));\n    externalLinksFieldsInput();\n    externalLinkDelete();\n    checkStep4();\n  });\n};\n\n/**\r\n * Delete external link.\r\n */\nvar externalLinkDelete = function externalLinkDelete() {\n  var buttons = document.querySelectorAll('.media-link-delete');\n  if (!buttons.length) return;\n  buttons.forEach(function (btn) {\n    btn.removeEventListener('click', onExternalLinkDelete);\n    btn.addEventListener('click', onExternalLinkDelete);\n  });\n};\n\n/**\r\n * Handle external link deletion.\r\n */\nvar onExternalLinkDelete = function onExternalLinkDelete(e) {\n  var link = e.target.closest('.step-media-link');\n  stepData.links.splice(link.dataset.id, 1);\n  link.remove();\n  localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n\n  // No more links\n  if (!document.querySelectorAll('.step-media-link').length) {\n    document.querySelector('.step-media-links').innerHTML = getExternalLinkHTML();\n    externalLinksFieldsInput();\n    externalLinkDelete();\n    checkStep4();\n    document.querySelector('.media-links-add').classList.add('hidden');\n  }\n};\n\n/**\r\n * Check if step 4 is ready.\r\n * Update local storage if it was cleared.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep4 = function checkStep4() {\n  var photos = document.querySelectorAll('.droparea-img-loaded:not(.droparea-video-loaded)'),\n    videos = document.querySelectorAll('.droparea-video-loaded'),\n    links = document.querySelectorAll('.step-media-link');\n  if (photos.length < 1) return false;\n  stepData.photos = [];\n  photos.forEach(function (photo) {\n    return stepData.photos.push(photo.querySelector('.droparea-img-delete').dataset.id);\n  });\n  if (videos.length) {\n    stepData.videos = [];\n    videos.forEach(function (video) {\n      var videoTag = video.querySelector('video'),\n        poster = videoTag ? videoTag.dataset.posterId : '';\n      stepData.videos.push({\n        poster: poster || '',\n        id: video.querySelector('.droparea-img-delete').dataset.id\n      });\n    });\n  }\n  if (links.length) {\n    stepData.links = [];\n    links.forEach(function (field) {\n      var urlField = field.querySelector('input[id^=\"media-link-\"]'),\n        urlTitle = field.querySelector('input[id^=\"media-name-link-\"]');\n      if (!urlField || !urlTitle) return;\n      stepData.links.push({\n        url: urlField.value,\n        title: urlTitle.value,\n        position: field.dataset.id\n      });\n    });\n  }\n  localStorage.setItem('ih-step-4', JSON.stringify(stepData));\n  return true;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-4.js?");

/***/ }),

/***/ "./src/js/new-memory/step-5.js":
/*!*************************************!*\
  !*** ./src/js/new-memory/step-5.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCoordsFormValidation: function() { return /* binding */ addCoordsFormValidation; },\n/* harmony export */   checkStep5: function() { return /* binding */ checkStep5; },\n/* harmony export */   legendTipClick: function() { return /* binding */ legendTipClick; }\n/* harmony export */ });\n/* harmony import */ var body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! body-scroll-lock */ \"./node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/js/new-memory/common.js\");\n/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/global */ \"./src/js/common/global.js\");\n\n\n\nvar stepData = localStorage.getItem('ih-step-5') ? JSON.parse(localStorage.getItem('ih-step-5')) : {};\n\n/**\r\n * Legend tip button click.\r\n */\nvar legendTipClick = function legendTipClick() {\n  var tip = document.querySelector('.legend-tip'),\n    popup = document.querySelector('#coords-popup'),\n    close = document.querySelector('#coords-popup .coords-popup-close');\n  if (!tip || !popup || !close) return;\n  tip.addEventListener('click', function () {\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.setTargetElement)('#coords-popup');\n    (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__.disableBodyScroll)((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.getTargetElement)(), {\n      reserveScrollBarGap: true\n    });\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.showElement)(popup);\n  });\n  close.addEventListener('click', function () {\n    (0,_common_global__WEBPACK_IMPORTED_MODULE_2__.hideElement)(popup);\n    (0,body_scroll_lock__WEBPACK_IMPORTED_MODULE_0__.enableBodyScroll)((0,_common_global__WEBPACK_IMPORTED_MODULE_2__.getTargetElement)());\n  });\n};\n\n/**\r\n * Validate Step 5 coords info form.\r\n */\nvar addCoordsFormValidation = function addCoordsFormValidation() {\n  var fields = document.querySelectorAll('.new-memory-coords input'),\n    textarea = document.querySelector('.new-memory-coords textarea');\n  if (!fields.length || !textarea) return;\n  fields.forEach(function (field) {\n    field.addEventListener('change', checkFieldValue);\n    field.addEventListener('keyup', checkFieldValue);\n    field.addEventListener('blur', checkFieldValue);\n  });\n  textarea.addEventListener('change', checkFieldValue);\n  textarea.addEventListener('keyup', checkFieldValue);\n  textarea.addEventListener('blur', checkFieldValue);\n};\nvar checkFieldValue = function checkFieldValue(e) {\n  var field = e.target,\n    value = field.value,\n    index = field.name;\n  if (!value) field.classList.add('error');else field.classList.remove('error');\n  stepData[index] = value;\n  localStorage.setItem('ih-step-5', JSON.stringify(stepData));\n  if (checkStep5()) {\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.allowNextStep)(6);\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.applyProgress)(5);\n  } else {\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.disallowNextStep)();\n    (0,_common__WEBPACK_IMPORTED_MODULE_1__.applyProgress)(5, 0);\n  }\n};\n\n/**\r\n * Check if Step 5 coords form is valid.\r\n *\r\n * @returns {boolean}\r\n */\nvar checkStep5 = function checkStep5() {\n  var fields = document.querySelectorAll('.new-memory-coords input'),\n    textarea = document.querySelector('.new-memory-coords textarea');\n  var isFormValid = true;\n  if (!fields.length || !textarea) return;\n  stepData.how_to_find = textarea.value;\n\n  // Fill stepData again in the case localStorage was cleared.\n  fields.forEach(function (field) {\n    var index = field.name,\n      value = field.value;\n    if (field.required && !value) isFormValid = false;\n    stepData[index] = value;\n  });\n  localStorage.setItem('ih-step-5', JSON.stringify(stepData));\n  return isFormValid;\n};\n\n//# sourceURL=webpack://inheart/./src/js/new-memory/step-5.js?");

/***/ }),

/***/ "./src/js/pages/new-memory.js":
/*!************************************!*\
  !*** ./src/js/pages/new-memory.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _new_memory_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../new-memory/common */ \"./src/js/new-memory/common.js\");\n/* harmony import */ var _new_memory_step_0__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../new-memory/step-0 */ \"./src/js/new-memory/step-0.js\");\n/* harmony import */ var _new_memory_step_1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../new-memory/step-1 */ \"./src/js/new-memory/step-1.js\");\n/* harmony import */ var _new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../new-memory/step-2 */ \"./src/js/new-memory/step-2.js\");\n/* harmony import */ var _new_memory_step_3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../new-memory/step-3 */ \"./src/js/new-memory/step-3.js\");\n/* harmony import */ var _new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../new-memory/step-4 */ \"./src/js/new-memory/step-4.js\");\n/* harmony import */ var _new_memory_step_5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../new-memory/step-5 */ \"./src/js/new-memory/step-5.js\");\n/* harmony import */ var _new_memory_step_2_military__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../new-memory/step-2-military */ \"./src/js/new-memory/step-2-military.js\");\n/* harmony import */ var _new_memory_step_3_military__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../new-memory/step-3-military */ \"./src/js/new-memory/step-3-military.js\");\n// Common functions for all steps.\n\n\n// Steps one-by-one.\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  'use strict';\n\n  // Exit if something is missing.\n  if (!(0,_new_memory_common__WEBPACK_IMPORTED_MODULE_0__.defineGlobalStepsItems)()) return;\n  var initialStep = parseInt(document.querySelector('.main.new-memory').dataset.initialStep);\n\n  // Step 0.\n  (0,_new_memory_common__WEBPACK_IMPORTED_MODULE_0__.isStepFilled)(initialStep);\n  (0,_new_memory_step_0__WEBPACK_IMPORTED_MODULE_1__.selectTheme)();\n  (0,_new_memory_common__WEBPACK_IMPORTED_MODULE_0__.nextStep)();\n\n  // Step 1.\n  (0,_new_memory_step_1__WEBPACK_IMPORTED_MODULE_2__.selectLanguage)();\n  (0,_new_memory_step_1__WEBPACK_IMPORTED_MODULE_2__.uploadMainPhoto)();\n  (0,_new_memory_step_1__WEBPACK_IMPORTED_MODULE_2__.addMainFormValidation)();\n  (0,_new_memory_common__WEBPACK_IMPORTED_MODULE_0__.prevStep)();\n\n  // Step 2 Military\n  (0,_new_memory_step_2_military__WEBPACK_IMPORTED_MODULE_7__.step2MilitaryFormValidation)();\n\n  // Step 3 Military\n  (0,_new_memory_step_3_military__WEBPACK_IMPORTED_MODULE_8__.addReward)();\n\n  // Step 2.\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.addSection)();\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.removeSidebarAddedSection)();\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.removeContentSection)();\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.setActiveSectionContent)();\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.dragOrderSections)();\n  (0,_new_memory_step_2__WEBPACK_IMPORTED_MODULE_3__.sectionsContentInput)();\n\n  // Step 3\n  (0,_new_memory_step_3__WEBPACK_IMPORTED_MODULE_4__.checkEpitaphContentLength)();\n\n  // Step 4\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.setDefaultDeletePhoto)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.setDefaultDeleteVideo)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.uploadMediaPhotos)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.uploadMediaVideo)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.videoLinkInput)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.uploadVideoLink)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.uploadCustomPoster)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.selectScreenshot)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.saveVideoPoster)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.externalLinksFieldsInput)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.externalLinkAdd)();\n  (0,_new_memory_step_4__WEBPACK_IMPORTED_MODULE_5__.externalLinkDelete)();\n\n  // Step 5\n  (0,_new_memory_step_5__WEBPACK_IMPORTED_MODULE_6__.addCoordsFormValidation)();\n  (0,_new_memory_step_5__WEBPACK_IMPORTED_MODULE_6__.legendTipClick)();\n});\n\n//# sourceURL=webpack://inheart/./src/js/pages/new-memory.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/pages/new-memory.js");
/******/ 	
/******/ })()
;